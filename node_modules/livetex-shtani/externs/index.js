/**
 * @namespace
 */
util.arr = {};


/**
 * @namespace
 */
util.config = {};


/**
 * @namespace
 */
util.cli = {};


/**
 * @namespace
 */
util.fn = {};


/**
 * @namespace
 */
util.hash = {};


/**
 * @namespace
 */
util.io = {};


/**
 * @namespace
 */
util.io.async = {};


/**
 * @namespace
 */
util.log = {};


/**
 * @namespace
 */
util.obj = {};


/**
 * @namespace
 */
util.uid = {};


/**
 * @namespace
 */
util.collector = {};


/**
 * @type {number}
 */
util.ENUM_SEED;


/**
 * Clones an object
 *
 * @param {*} value Value to clone.
 * @return {*} Copy of an object.
 */
util.clone = function(value) {};


/**
 * Compares two objects
 *
 * @param {*} first Object to compare.
 * @param {*} second Object to compare.
 * @return {boolean} Result of comparison.
 */
util.equals = function(first, second) {};


/**
 * Encodes object to JSON.
 *
 * @param {*} object The object to code.
 * @return {string} JSON string.
 */
util.encodeJson = function(object) {};


/**
 * Converts JSON to object.
 *
 * @param {string} data JSON string..
 * @return {*} JSON object.
 */
util.decodeJson = function(data) {};


/**
 * Encodes string to base64 format.
 *
 * @param {string} string Строка.
 * @param {boolean=} opt_forUrl Флаг URL-безопасного кодирования.
 * @return {string} Закодированная строка.
 */
util.encodeBase64 = function(string, opt_forUrl) {};


/**
 * Converts base64 to ordinary string.
 *
 * @param {string} string Base64 string.
 * @param {boolean=} opt_forUrl Flag for URL-safe decoding.
 * @return {string} Decoded string.
 */
util.decodeBase64 = function(string, opt_forUrl) {};


/**
 * Converts object to x-www-form-urlencoded.
 *
 * @param {!Object} object Object to encode.
 * @param {string=} opt_separator Separator for name/value pairs.
 * @return {string} Encoded string.
 */
util.encodeFormData = function(object, opt_separator) {};


/**
 * Converts string in x-www-form-urlencoded to object.
 *
 * @param {string} formData String in x-www-form-urlencoded.
 * @param {string=} opt_separator Separator for name/value pairs.
 * @return {!Object} Decoded object.
 */
util.decodeFormData = function(formData, opt_separator) {};


/**
 * Encodes special characters in url.
 *
 * @param {string} url URL-string.
 * @return {string} Encoded string.
 */
util.escape = function(url) {};


/**
 * Decodes special characters in url.
 *
 * @param {string} url URL-string.
 * @return {string} Decoded string.
 */
util.unescape = function(url) {};


/**
 * Removes whitespace from both sides of a string.
 *
 * @param {string} string String.
 * @return {string} Trimmed string.
 */
util.trim = function(string) {};


/**
 * @param {!Object} data Data.
 * @param {string} key Data key.
 * @return {string} String.
 */
util.extractString = function(data, key) {};


/**
 * @param {!Object} data Data.
 * @param {string} key Data key.
 * @return {number} String.
 */
util.extractNumber = function(data, key) {};


/**
 * @param {!Object} data Data.
 * @param {string} key Data key.
 * @return {boolean} String.
 */
util.extractBoolean = function(data, key) {};


/**
 * @param {!Object} data Data.
 * @param {string} key Data key.
 * @return {!Object} String.
 */
util.extractObject = function(data, key) {};


/**
 * Binds a function to a certain context.
 *
 * @param {!Function} fn Function to bind.
 * @param {Object} context Context.
 * @return {!Function} Binded function.
 */
util.fn.bind = function(fn, context) {};


/**
 * Creates a key-value table.
 *
 * @param {!Array.<string>} keys Keys for a table.
 * @param {!Array} values Values for a table.
 * @return {!Object} Table.
 */
util.obj.glue = function(keys, values) {};


/**
 * Creates an safe object
 *
 * @param {Object} obj Object.
 * @return {!util.obj.SafeObject} Safe object.
 */
util.obj.safe = function(obj) {};


/**
 * Clones an object
 *
 * @param {!Object} value Value to clone.
 * @return {!Object} Copy of an object.
 */
util.obj.clone = function(value) {};


/**
 * Merges two objects.
 *
 * @param {!Object} base Base object to merge.
 * @param {!Object} target Object to merge with base object.
 * @return {!Object} Result of merging.
 */
util.obj.merge = function(base, target) {};


/**
 * Compares two objects
 *
 * @param {!Object} first Object to compare.
 * @param {!Object} second Object to compare.
 * @return {boolean} Result of comparison.
 */
util.obj.equals = function(first, second) {};


/**
 * @interface
 */
util.obj.ISafeObject = function() {};


/**
 * Returns data.
 *
 * @param {...(string|number)} var_args Path to value.
 * @return {*} Data.
 */
util.obj.ISafeObject.prototype.get = function(var_args) {};


/**
 * Stores data to a key by its path.
 *
 * @param {*} value Data.
 * @param {...(string|number)} var_args Path to value.
 */
util.obj.ISafeObject.prototype.set = function(value, var_args) {};


/**
 * Returns data stored at key with certain path.
 *
 * @param {!Array.<(string|number)>} path Path to value.
 * @return {*} Data.
 */
util.obj.ISafeObject.prototype.getByPath = function(path) {};


/**
 * Stores data to a key with certain path.
 *
 * @param {*} value Data.
 * @param {!Array.<(string|number)>} path Path to value.
 */
util.obj.ISafeObject.prototype.setByPath = function(value, path) {};


/**
 * @constructor
 * @implements {util.obj.ISafeObject}
 * @param {!Object} data Source data.
 */
util.obj.SafeObject = function(data) {};


/**
 * Returns source data.
 *
 * @return {!Object} Source data.
 */
util.obj.SafeObject.prototype.getCore = function() {};


/**
 * @param {...(string|number)} var_args Path to value.
 * @return {*} Data.
 */
util.obj.SafeObject.prototype.get = function(var_args) {};


/**
 * @param {*} value Data.
 * @param {...(string|number)} var_args Path to value.
 */
util.obj.SafeObject.prototype.set = function(value, var_args) {};


/**
 * @inheritDoc
 */
util.obj.SafeObject.prototype.getByPath = function(path) {};


/**
 * @inheritDoc
 */
util.obj.SafeObject.prototype.setByPath = function(value, path) {};


/**
 * @param {...string} var_args
 * @return {string}
 */
util.obj.SafeObject.prototype.getString = function(var_args) {};


/**
 * @param {...string} var_args
 * @return {number}
 */
util.obj.SafeObject.prototype.getNumber = function(var_args) {};


/**
 * @param {...string} var_args
 * @return {boolean}
 */
util.obj.SafeObject.prototype.getBoolean = function(var_args) {};


/**
 * @param {...string} var_args
 * @return {!Object}
 */
util.obj.SafeObject.prototype.getObject = function(var_args) {};


/**
 * @interface
 */
util.obj.ICache = function() {};


/**
 * @param {string} key Ключ хранения.
 * @return {*} Сушность.
 */
util.obj.ICache.prototype.pull = function(key) {};


/**
 * @param {string} key Ключ хранения.
 * @param {*} entity Cущность.
 */
util.obj.ICache.prototype.stash = function(key, entity) {};


/**
 * @constructor
 * @implements {util.obj.ICache}
 */
util.obj.Cache = function() {};


/**
 * @override
 */
util.obj.Cache.prototype.pull = function(key) {};


/**
 * @override
 */
util.obj.Cache.prototype.stash = function(key, entity) {};


/**
 * Очищение кеша.
 */
util.obj.Cache.prototype.flush = function() {};


/**
 * JS Implementation of MurmurHash2
 *
 * @see http://github.com/garycourt/murmurhash-js
 * @see http://sites.google.com/site/murmurhash/
 *
 * @param {string} str ASCII only.
 * @param {number} seed Random seed.
 * @return {number} 32-bit positive integer hash.
 */
util.hash.murmur = function(str, seed) {};


/**
 *
 *
 * @interface
 */
util.uid.IIdGenerator = function() {};


/**
 * Generates id.
 *
 * @return {string} Generated identificator.
 */
util.uid.IIdGenerator.prototype.generateId = function() {};


/**
 *
 *
 * @constructor
 * @implements {util.uid.IIdGenerator}
 * @param {string} prefix Prefix for identifier.
 * @param {boolean=} opt_isIncremental Flag whether to use an increment or not.
 */
util.uid.PrefixIdGenerator = function(prefix, opt_isIncremental) {};


/**
 * Generates identifier.
 *
 * @inheritDoc
 */
util.uid.PrefixIdGenerator.prototype.generateId = function() {};


/**
 * Returns identifier's prefix.
 *
 * @return {string} Prefix of identifier.
 */
util.uid.PrefixIdGenerator.prototype.getPrefix = function() {};


/**
 * Search the index of an element in array.
 *
 * @param {*} element element to find.
 * @param {!Array} array Array containing an element.
 * @return {number} Index of element.
 */
util.arr.indexOf = function(element, array) {};


/**
 * Creates array of unique strings..
 *
 * @param {!Array.<string>} set Array of strings.
 * @return {!Array.<string>} Array of unique strings.
 */
util.arr.unique = function(set) {};


/**
 * Fills array with data.
 *
 * @param {!Array.<*>} array Array to fill.
 * @param {*} value Data.
 * @return {!Array.<*>} Filled array.
 */
util.arr.fill = function(array, value) {};


/**
 * Creates an array.
 *
 * @param {number} length Size of array.
 * @param {*=} opt_defaultValue Default value to set for each element of array.
 * @return {!Array.<*>} Array.
 */
util.arr.create = function(length, opt_defaultValue) {};


/**
 * Clones an array
 *
 * @param {!Array} array Array o clone.
 * @return {!Array} Copy of the array.
 */
util.arr.clone = function(array) {};


/**
 * Converts object to array.
 *
 * @param {{length: number}} list Object resembles an array.
 * @return {!Array} Array.
 */
util.arr.cast = function(list) {};


/**
 * Converts each element of an array to string.
 *
 * @param {{length: number}} list Object resembles an array.
 * @return {!Array.<string>} array of strings.
 */
util.arr.castString = function(list) {};


/**
 * Converts each element of an array to object
 *
 * @param {{length: number}} list Object resembles an array.
 * @return {!Array.<!Object>} Array of objects.
 */
util.arr.castObject = function(list) {};


/**
 * @param {string} name Имя переменной.
 * @return {!Array} Значение.
 */
util.cli.getArray = function(name) {};


/**
 * @param {string} name Имя переменной.
 * @return {string} Значение.
 */
util.cli.getString = function(name) {};


/**
 * @param {string} name Имя переменной.
 * @return {number} Значение.
 */
util.cli.getNumber = function(name) {};


/**
 * @param {string} name Имя переменной.
 * @return {boolean} Значение.
 */
util.cli.getBoolean = function(name) {};


/**
 * @param {string} filename Путь к файлу с конфигом.
 */
util.config.load = function(filename) {};


/**
 * @param {...(string|number)} var_args Путь к данным.
 * @return {string} Результат.
 */
util.config.getString = function(var_args) {};


/**
 * @param {...(string|number)} var_args Путь к данным.
 * @return {number} Результат.
 */
util.config.getNumber = function(var_args) {};


/**
 * @param {...(string|number)} var_args Путь к данным.
 * @return {boolean} Результат.
 */
util.config.getBoolean = function(var_args) {};


/**
 * @param {...(string|number)} var_args Путь к данным.
 * @return {!Object} Результат.
 */
util.config.getObject = function(var_args) {};


/**
 * @param {...(string|number)} var_args Путь к данным.
 * @return {!Array.<string>} Результат.
 */
util.config.getObjectKeys = function(var_args) {};


/**
 * @param {...(string|number)} var_args Путь к данным.
 * @return {!Array} Результат.
 */
util.config.getArray = function(var_args) {};


/**
 * @typedef {?function(!Object=):string}
 */
util.log.AdditionalLog;


/**
 * @param {number=} opt_level
 * @param {!util.log.AdditionalLog=} opt_additionalLog .
 */
util.log.init = function(opt_level, opt_additionalLog) {};


/**
 * @enum {string}
 */
util.log.Prefix = {
  INFO: '[INFO]',
  WARN: '[WARNING]',
  ERROR: '[ERROR]',
  ERROR_STACK: 'ERROR STACK'
};


/**
 * @enum {string}
 */
util.log.Color = {
  GREEN: '\033[32m',
  YELLOW: '\033[33m',
  RED: '\033[31m',
  MAGENTA: '\033[35m',
  LIGHT_GRAY: '\033[1;30m',
  __RESET: '\033[0m'
};


/**
 * Encodes object to JSON.
 *
 * @param {*} object The object to code.
 * @return {string} JSON string.
 */
util.io.encodeJson = function(object) {};


/**
 * Converts JSON to object.
 *
 * @param {string} data JSON string..
 * @return {*} JSON object.
 */
util.io.decodeJson = function(data) {};


/**
 * Encodes string to base64 format.
 *
 * @param {string} string Строка.
 * @param {boolean=} opt_forUrl Флаг URL-безопасного кодирования.
 * @return {string} Закодированная строка.
 */
util.io.encodeBase64 = function(string, opt_forUrl) {};


/**
 * Converts base64 to ordinary string.
 *
 * @param {string} string Base64 string.
 * @param {boolean=} opt_forUrl Flag for URL-safe decoding.
 * @return {string} Decoded string.
 */
util.io.decodeBase64 = function(string, opt_forUrl) {};


/**
 * Converts object to x-www-form-urlencoded.
 *
 * @param {!Object} object Object to encode.
 * @param {string=} opt_separator Separator for name/value pairs.
 * @return {string} Encoded string.
 */
util.io.encodeFormData = function(object, opt_separator) {};


/**
 * Converts string in x-www-form-urlencoded to object.
 *
 * @param {string} formData String in x-www-form-urlencoded.
 * @param {string=} opt_separator Separator for name/value pairs.
 * @return {!Object} Decoded object.
 */
util.io.decodeFormData = function(formData, opt_separator) {};


/**
 * Encodes special characters in url.
 *
 * @param {string} url URL-string.
 * @return {string} Encoded string.
 */
util.io.escape = function(url) {};


/**
 * Decodes special characters in url.
 *
 * @param {string} url URL-string.
 * @return {string} Decoded string.
 */
util.io.unescape = function(url) {};


/**
 * Основная область имен библотеки.
 *
 * Библиотека предназначена для организации алгоритмов асинхронной обработки
 * данных.
 *
 * Основным понятиями асинхронного алгоритма являются шаг и сценарий, состоящий
 * из множества шагов. В свою очередь шаг является сценарием состоящим из
 * соответсвующего шага.
 *
 * @namespace
 */
var async = {};


/**
 * @namespace
 */
async.assert = {};


/**
 * @namespace
 */
async.console = {};


/**
 * Область имен объединяющая функции для работы с входными данными сценария.
 *
 * @namespace
 */
async.input = {};


/**
 * @namespace
 */
async.input.cursor = {};


/**
 * @namespace
 */
async.input.cursor.cache = {};


/**
 * @namespace
 */
async.input.cursor.filter = {};


/**
 * Область имен объединяющая функции для работы с результатом выполнения.
 *
 * @namespace
 */
async.output = {};


/**
 * Область имен объединяющая функции для создания сценариев обработки
 * входных данных.
 *
 * @namespace
 */
async.proc = {};


/**
 * Область имен объединяющая функции для создания сценариев обработки
 * входных наборов данных.
 *
 * @namespace
 */
async.proc.fold = {};


/**
 * Область имен объединяющая функции для создания сценариев обработки
 * входных наборов данных соответсвующим набором шагов.
 *
 * @namespace
 */
async.proc.zip = {};


/**
 * @namespace
 */
async.index = {};


/**
 * Все, что может выступать в качетсве контекста шага.
 *
 * @see async.Step
 * @see async.Step#call
 *
 * @typedef {*}
 */
async.Context;


/**
 * Все, что может выступать в качетсве входных данных шага.
 *
 * @see async.Step
 * @see async.Step#call
 *
 * @typedef {*}
 */
async.Input;


/**
 * Все, что может выступать в качетсве результата выполнения шага.
 *
 * @see async.CompleteHandler
 *
 * @see async.Step
 * @see async.CompleteHandler
 *
 * @typedef {*}
 */
async.Output;


/**
 * Обработчик результата выполнения шага.
 *
 * Обработчиком является функция принимающая в качетве аргумента результат
 * выполнения шага.
 *
 * @see async.Step
 * @see async.Step#call
 * @see async.Output
 *
 * @typedef {?function(async.Output)}
 */
async.CompleteHandler;


/**
 * Все, что может выступать в качетсве ошибки выполнения шага.
 *
 * @see async.ErrorHandler
 *
 * @typedef {*}
 */
async.Error;


/**
 * Обработчик ошибки выполнения шага.
 *
 * Обработчиком является функция принимающая в качетве аргументов оюъект ошибки
 * и ее код. Код ошибки является необязательным параметром.
 *
 * @see async.Step
 * @see async.Step#call
 * @see async.Error
 *
 * @typedef {?function(async.Error, number=)}
 */
async.ErrorHandler;


/**
 * Шаг сценария.
 *
 * @see async.IStep
 * @see async.Scenario
 *
 * @typedef {async.IStep|?function(async.Input, !async.CompleteHandler,
 *    !async.ErrorHandler)}
 */
async.Step;


/**
 * Сценарий выполенения.
 *
 * Сценарием является шаг, в рамках выполнения которого по определенному правилу
 * связывается выполнение множества шагов с помощью соответсвующих обработчиков
 * результата либо ошибки. Запуск выполнения шагов сценария определяется
 * соответсвующим правилом.
 *
 * Для большинства сценариев вызов обработчика ошибки одного из шагов, влечет
 * за собой вызов обработчика ошибки сценария и прекращению дальнейшего
 * выполнения шагов.
 *
 * @see async.try
 * @see async.Step
 * @see async.ErrorHandler
 * @see async.Sequence
 * @see async.Parallel
 *
 * @typedef {async.Step}
 */
async.Scenario;


/**
 * Сценарий последовательного выполнения.
 *
 * Сценарий последовательного выполнения определяется множеством шагов,
 * выполнение которых будет вызвано последовательно в асинхронном смысле.
 *
 * Последовательно в асинхронном смысле означает то, что выполнение шагов
 * сценария не пересекается во времени.
 *
 * Для последовательного выполнения актуально наличие условия продолжнения,
 * условия, невыполнение которого ведет к прерыванию поледовательности
 * выполнения.
 *
 * @see async.Step
 * @see async.Scenario
 * @see async.ConditionStep
 *
 * @typedef {async.Scenario}
 */
async.Sequence;


/**
 * Сценарий параллельного выполнения.
 *
 * Паралельность в асинхронном смысле означает то, выполнение всех шагов
 * сценария может пересечься во времени.
 *
 * @see async.Step
 * @see async.Scenario
 *
 * @typedef {async.Scenario}
 */
async.Parallel;


/**
 * Шаг проверки условия.
 *
 * Результатом шага проверки должно являтся булево значение результата
 * проверки.
 *
 * @see async.Input
 * @see async.Step
 * @see async.Sequence
 *
 * @typedef {async.Step}
 */
async.ConditionStep;


/**
 * @typedef {?function(...):!async.Step}
 */
async.StepRouter;


/**
 * Создатель шага обработки ошибки, который будет вызван при появении первой
 * ошибки целевого шага.
 *
 * Созданный обработчик вызовется в качетсве "замены" целевого шага с
 * соответсвующими входными данными и контекстом.
 *
 * Собственные ошибки обработчика не будут отловлены и повлияют на выполнение
 * сценария, в рамках котрого была выполнена попытка отловить ошибки целевого
 * шага.
 *
 * @see async.try
 * @see async.IStep
 * @see async.Input
 * @see async.Context
 *
 * @typedef {?function(async.Error, number=):!async.Step}
 */
async.FailCatcher;


/**
 * Создатель обработчика ошибки не влияющего на ход выполнения сценария.
 *
 * Созданный обработчик вызывается при появлении любой ошибки при
 * выполнении целевого шага.
 *
 * Обработчик ошибки будет вызвваться в контексте сценария.
 *
 * @see async.FailCatcher
 * @see async.IStep
 *
 * @typedef {?function():!async.ErrorHandler}
 */
async.TolerantCatcher;


/**
 * Создание пустого обработчика ошибки.
 *
 * @return {!async.ErrorHandler} Обработчик ошибки.
 */
async.NOP_CATCHER = function() {};


/**
 * Шаг проверки, всегда возвращающий положительный результат.
 *
 * @see async.ConditionStep
 *
 * @param {async.Input} input Входные данные.
 * @param {!async.CompleteHandler} complete Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.IS_INPUT = function(input, complete, cancel) {};


/**
 * Шаг проверки, того входные данные не `null`.
 *
 * @see async.ConditionStep
 *
 * @param {async.Input} input Входные данные.
 * @param {!async.CompleteHandler} complete Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.IS_NOT_NULL = function(input, complete, cancel) {};


/**
 * Шаг проверки, того входные данные равны `null`.
 *
 * @see async.ConditionStep
 *
 * @param {async.Input} input Входные данные.
 * @param {!async.CompleteHandler} complete Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.IS_NULL = function(input, complete, cancel) {};


/**
 * Шаг немедленно возращающий переданное ему значение без изменений.
 *
 * @param {async.Input} input Входные данные.
 * @param {!async.CompleteHandler} complete Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.nop = function(input, complete, cancel) {};


/**
 * Создание шага передающего указанные входные данные в обработчик результата.
 *
 * @see async.Input
 * @see async.Output
 *
 * @param {async.Input} input Входные данные.
 * @return {!async.Step} Созданный шаг.
 */
async.insert = function(input) {};


/**
 * @param {!async.Step} step Шаг требующий соответсвующие входные данные.
 * @param {!async.Step=} opt_target Шаг получения входных данных.
 * @return {!async.Step} Созданный шаг.
 */
async.use = function(step, opt_target) {};


/**
 * Приведения "полушага" к шагу.
 *
 * Полушагом является функция в качестве аргументов принимающая обработчик
 * результата и обработчик ошибки соотвствующего вида после всех обязательных
 * параметров и до опциональных. Например:
 *
 * ```
 * function semiActor(a, b, c, <b>complete</b>, <b>cancel</b>, opt_d, opt_b) {
 *   // ...
 * }
 * ```
 *
 * Таким образом, полушаг является функцией, обязательные и опциональные
 * аргументы которого разделены функциями обработки результата и ошибки.
 *
 * Приведение осуществляется за счет выполнения шагов источников значений
 * аргументов и передачи их результата в вызов полушага. Входными данными для
 * каждого источника являются данные вызова созданного шага.
 *
 * Так, например, для передачи входных данных шага в каждый из обязательных
 * аргументов полушага приведение и вызов будет выглядеть следующим образом:
 *
 * ```
 * var actor = async.cast(semiActor, [async.nop, async.nop, async.nop]);
 * actor.call(null, 1, console.log, console.error);
 * ```
 *
 * Так как шаг `async.nop` передает входные данные в обработчик результата, в
 * аргументы `a`, `b` и `c` будет передано входное значение `1`.
 *
 * @see async.CompleteHandler
 * @see async.ErrorHandler
 * @see async.Step
 * @see async.nop
 *
 * @param {function(...)} semiActor Полушаг.
 * @param {!Array.<!async.Step>} sources Массив источников значений
 *    обязательных аргументов соответсвующий их последовательнотии в полушаге.
 * @param {!Array.<!async.Step>=} opt_sources Массив источников значений не
 *    обязательных аргументов соответсвующий их последовательнотии в полушаге.
 * @return {!async.Step} Созданный шаг.
 */
async.cast = function(semiActor, sources, opt_sources) {};


/**
 * Приведения любой функции к шагу.
 *
 * Приведение осуществляется за счет передачи результата выполнения заданной
 * функции в обработчик результата.
 *
 * Передача агрументов в заданную функцию осуществляется при небхожимости
 * тем же способом что и для `async.cast`.
 *
 * @see async.Step
 * @see async.cast
 * @param {function(...)} fn Заданная функция.
 * @param {!Array.<!async.Step>=} opt_sources Массив источников значений
 *    аргументов соответсвующий их последовательнотии в заданной функции.
 * @return {!async.Step} Созданный шаг.
 */
async.wrap = function(fn, opt_sources) {};


/**
 * @param {!async.Step} condition Шаг условия.
 * @return {!async.Step} Шаг фильтрации.
 */
async.filter = function(condition) {};


/**
 * Создание сценария последовательной обработки результата предыдущего шага.
 *
 * Перый шаг в качеcтве входных данных получает входные данные созданного
 * сценария.
 *
 * Шаг проверки получает на вход данные каждого шага сценария.
 *
 * @see async.ConditionStep
 * @see async.Sequence
 *
 * @param {!Array.<!async.Step>} steps Набор шагов.
 * @param {!async.ConditionStep=} opt_condition Шаг проверки условия
 *    продолжения последовательности.
 * @return {!async.Sequence} Созданный сценарий.
 */
async.sequence = function(steps, opt_condition) {};


/**
 * Последовательность шагов, выполняемая пока каждый шаг получает на вход
 * значение, отличающееся от `null`.
 *
 * @see async.ConditionStep
 * @see async.Sequence
 * @see async.IS_NOT_NULL
 *
 * @param {!Array.<!async.Step>} steps Набор шагов.
 * @return {!async.Scenario} Созданный сценарий.
 */
async.chain = function(steps) {};


/**
 * Последовательность шагов, выполняемая пока каждый шаг получает на вход
 * значение равняющееся `null`.
 *
 * @see async.ConditionStep
 * @see async.Sequence
 * @see async.IS_NULL
 *
 * @param {!Array.<!async.Step>} steps Набор шагов.
 * @return {!async.Scenario} Созданный сценарий.
 */
async.fallback = function(steps) {};


/**
 * @param {!async.StepRouter} router
 * @param {!(Array.<!async.Step>|async.Step)=} opt_decoder
 * @param {...!async.Step} var_args
 * @return {!async.Step}
 */
async.route = function(router, opt_decoder, var_args) {};


/**
 * @param {function(...)} fn Заданная функция.
 * @param {...!async.Step} var_args
 * @return {!async.Step}
 */
async.combine = function(fn, var_args) {};


/**
 * Создание шага переключения сценария.
 *
 * Переключение осуществляется за счет шага получения ключа, поиска
 * соответсвующего шага по таблице вызова и его выполнения.
 *
 * Результат шага получения ключа используется в качестве ключа в таблице
 * вызова.
 *
 * В случае если ключ отсутствует в таблице, вызывается соответсвующий шаг
 * по умолчанию.
 *
 * @see async.switch
 *
 * @param {!async.Step} condition Шаг получения ключа вызова.
 * @param {!Object.<*, !async.Step>} map Таблица вызова.
 * @param {!async.Step=} opt_default Шаг по-умолчанию, вызываемый в случае если
 *    ключ вызова отсутствует в теблице.
 * @return {!async.Step} Созданнй шаг.
 */
async.switch = function(condition, map, opt_default) {};


/**
 * Создание шага условного выполнения.
 *
 * @see async.switch
 *
 * @param {!async.ConditionStep} condition Шаг проверки услови.
 * @param {!async.Step} then Шаг выполняемый при успешном результате проверки.
 * @param {!async.Step=} opt_else Шаг вызываемый в случае, если результат
 *    проверки отрицательный.
 * @return {!async.Step} Созданнй шаг.
 */
async.if = function(condition, then, opt_else) {};


/**
 * Создание сценария циклического выполнения.
 *
 * Выполнение сценария заключается в повторении заданного шага. В качетве
 * входных данных шагу переддается результат его предыдущего выполнения.
 *
 * Входными данными первого вызова являются данные вызова созданного сценария.
 *
 * @param {!async.ConditionStep} condition Шаг проверки условия.
 * @param {!async.Step} step Повторяемый шаг.
 * @return {!async.Scenario} Созданный сценарий.
 */
async.while = function(condition, step) {};


/**
 * Создания сценария циклического выполнения соответвующего шага указанное
 * количесво раз.
 *
 * @see async.while
 *
 * @param {!async.Step} step Повторяемый шаг.
 * @param {number} count Количество повторений.
 * @return {!async.Scenario} Созданный сценарий.
 */
async.loop = function(step, count) {};


/**
 * Шаг, в результат обработки которого передается текущий контекст.
 *
 * @this {async.Context}
 * @param {async.Input} input Входные данные.
 * @param {!async.CompleteHandler} complete Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.context = function(input, complete, cancel) {};


/**
 * Содание шага, привязывающего контекст созданный специальным шагом для
 * выполнения целевого.
 *
 * @param {!async.Step} actor Целевой шаг.
 * @param {!async.Step} isolator Шаг создания контекста.
 * @return {!async.Step} Созданный шаг.
 */
async.bind = function(actor, isolator) {};


/**
 * Создание шага, ошибки выполнения которого, не повлияют на выполнение
 * сценария, за счет отлова возникающих ошибок с помощью соответсвующей фабрики,
 * для которого указанный шаг будет целевым.
 *
 * @see async.FailCatcher
 * @see async.TolerantCatcher
 *
 * @param {!async.Step} actor Целевой шаг.
 * @param {!async.FailCatcher} failCatcher Создатель шага обработки.
 * @param {!async.TolerantCatcher=} opt_errorCatcher Создатель
 *    обработчика ошибки не влиябщего на выполнения сценария.
 * @return {!async.Step} Созданный шаг.
 */
async.try = function(actor, failCatcher, opt_errorCatcher) {};


/**
 * Обертка для объевления шага в общем виде.
 *
 * @param {function(...)} strictActor Шаг с уточненными типами.
 * @return {!async.Step} Он же, объявленный в общем виде.
 */
async.esc = function(strictActor) {};


/**
 * Интерфейс шага сценария.
 *
 * Шаг сценаря определяется состоянием контекста выполенния, входными данными и
 * результатом выполнения.
 *
 * Результатом выполенния шага является единственный вызов обработчика
 * результата либо более одного вызова обработчика ошибки.
 *
 * Обработчик результата принимает обязательный аргумент с результатом
 * выполнения.
 *
 * В случае не попадания шага под определение, ни одна из изпользующих его
 * функций не может обеспечить корректной работы.
 *
 * @see async.Input
 * @see async.Output
 * @see async.CompleteHandler
 * @see async.Step
 * @see async.Scenario
 * @see async.IStep#call
 *
 * @interface
 */
async.IStep = function() {};


/**
 * Выполнение шага.
 *
 * Вызов обработчика ошибки является признаком ошибки выполнения и влияет на
 * выполенние всего сценария.
 *
 * @see async.Scenario
 *
 * @param {async.Context} context Контекст выполнения.
 * @param {async.Input} input Входные данные.
 * @param {!async.CompleteHandler} complete Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.IStep.prototype.call = function(context, input, complete, cancel) {};


/**
 * @interface
 * @extends {async.IStep}
 */
async.IValue = function() {};


/**
 * @return {async.Input}
 */
async.IValue.prototype.getValue = function() {};


/**
 * @param {async.Input} value
 * @return {async.Input}
 */
async.IValue.prototype.setValue = function(value) {};


/**
 * @param {!async.Value} value
 * @return {boolean}
 */
async.IValue.prototype.isEqualTo = function(value) {};


/**
 * Создание шага присвоения значения переменной.
 *
 * @param {!async.Step=} opt_source Шаг получения входных данных.
 * @return {!async.Step} Созданный шаг.
 */
async.IValue.prototype.assign = function(opt_source) {};


/**
 * @return {!async.Step}
 */
async.IValue.prototype.exists = function() {};


/**
 * @return {!async.Step}
 */
async.IValue.prototype.notExists = function() {};


/**
 * @param {!async.Step} value Значение.
 * @return {!async.Step}
 */
async.IValue.prototype.equals = function(value) {};


/**
 * @param {!async.Step} value Значение.
 * @return {!async.Step}
 */
async.IValue.prototype.notEquals = function(value) {};


/**
 * @constructor
 * @implements {async.IValue}
 * @param {async.Input=} opt_value
 */
async.Value = function(opt_value) {};


/**
 * @override
 */
async.Value.prototype.call = function(context, input, complete, cancel) {};


/**
 * @override
 */
async.Value.prototype.assign = function(opt_source) {};


/**
 * @override
 */
async.Value.prototype.exists = function() {};


/**
 * @override
 */
async.Value.prototype.notExists = function() {};


/**
 * @override
 */
async.Value.prototype.equals = function(value) {};


/**
 * @override
 */
async.Value.prototype.notEquals = function(value) {};


/**
 * @override
 */
async.Value.prototype.getValue = function() {};


/**
 * @override
 */
async.Value.prototype.setValue = function(value) {};


/**
 * @override
 */
async.Value.prototype.isEqualTo = function(value) {};


/**
 * @constructor
 * @param {!async.CompleteHandler} complete Обработчик результата итерации.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.Request = function(complete, cancel) {};


/**
 * @param {async.Input} output результат.
 */
async.Request.prototype.complete = function(output) {};


/**
 * @param {async.Error} error Ошибка.
 * @param {number=} opt_code Код ошибки.
 */
async.Request.prototype.cancel = function(error, opt_code) {};


/**
 * Создание шага утверждения.
 *
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.fail = function(message, opt_code) {};


/**
 * Создание шага утверждения.
 *
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.true = function(message, opt_code) {};


/**
 * Создание шага утверждения.
 *
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.false = function(message, opt_code) {};


/**
 * Создание шага утверждения.
 *
 * @param {async.Input} value Занчение.
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.equals = function(value, message, opt_code) {};


/**
 * Создание шага утверждения.
 *
 * @param {async.Input} value Занчение.
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.notEquals = function(value, message, opt_code) {};


/**
 * Создание шага утверждения.
 *
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.null = function(message, opt_code) {};


/**
 * Создание шага утверждения.
 *
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.notNull = function(message, opt_code) {};


/**
 * Создание шага утверждения.
 *
 * @param {string|!Function} type Тип.
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.type = function(type, message, opt_code) {};


/**
 * Сценарий, задачей которого является обработка входных данных с помощью
 * соответсвующих шагов и сбор результатов выполнения.
 *
 * В каждый шаг такого сценария будут переданы входные данные.
 *
 * В качетве накопителя по умолчанию для всех создаваемых сценариев будет
 * выбран создатель игнорирующего накопителя `async.output.NOP_COLLECTOR`.
 *
 * @see async.Step
 * @see async.Parallel
 * @see async.Sequence
 * @see async.output.ICollector
 * @see async.output.NopCollector
 *
 * @typedef {async.Scenario}
 */
async.proc.Scenario;


/**
 * Создание сценария параллельной обработки входных данных
 * заднным набором шагов.
 *
 * Для созданного сценария правилом параллельного вызова будет вызов шагов
 * сценария прямым перебором. Без передачи данных от шага к шагу.
 *
 * @see async.Parallel
 * @see async.proc.Scenario
 * @see async.output.ICollector
 *
 * @param {!Array.<!async.Step>} steps Набор шагов.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @return {!async.proc.Scenario} Созданный сценарий.
 */
async.proc.parallel = function(steps, opt_collector) {};


/**
 * Создание сценария последовательной обработки входных даных
 * заданным набором шагов.
 *
 * Входные данные шага проверки условия - данные промежуточного
 * результата выполнения созданного сценария.
 *
 * @see async.Sequence
 * @see async.proc.Scenario
 * @see async.output.ICollector
 * @see async.ConditionStep
 *
 * @param {!Array.<!async.Step>} steps Набор шагов.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @param {!async.ConditionStep=} opt_condition Шаг проверки условия
 *    продолжения последовательности.
 * @return {!async.proc.Scenario} Созданный сценарий.
 */
async.proc.sequence = function(steps, opt_collector, opt_condition) {};


/**
 * Создание сценария обработки входных данных единственным шагом.
 *
 * @param {!async.Step} step Выбранный шаг.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @return {!async.proc.Scenario} Созданный сценарий.
 */
async.proc.one = function(step, opt_collector) {};


/**
 * Создание сценария обработки входных данных единственным шагом заданное
 * количество раз.
 *
 * @param {async.Step} step Шаг.
 * @param {number} count Количество повторений.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @return {!async.proc.Scenario} Созданный сценарий.
 */
async.proc.loop = function(step, count, opt_collector) {};


/**
 * Сценарий, задачей которого является обработка элементов входного набора
 * данных с помощью соответсвующих шагов и сбор результатов выполнения.
 *
 * В каждый из соответсвующего набора шагов такого сценария будет передан
 * элемент входного набора данных.
 *
 * В качетве накопителя по умолчанию для всех создаваемых сценариев будет
 * выбран создатель собирающего накопителя `async.output.FLAT_COLLECTOR`.
 *
 * @see async.IStep
 * @see async.input.DataSet
 * @see async.input.IIterator
 * @see async.output.ICollector
 * @see async.output.FlatCollector
 *
 * @typedef {async.proc.Scenario}
 */
async.proc.fold.Scenario;


/**
 * Создание сценария параллельной обработки каждого элемента входного набора
 * данных с помощью соответсвующего шага.
 *
 * @see async.Parallel
 * @see async.proc.fold.Scenario
 * @see async.input.IIterator
 * @see async.output.ICollector
 *
 * @param {!async.Step} handler Шаг обработки.
 * @param {!async.input.IteratorCreator=} opt_iterator Создатель итератора
 *    входного набора данных.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @return {!async.proc.fold.Scenario} Созданный сценарий.
 */
async.proc.fold.parallel = function(handler, opt_iterator, opt_collector) {};


/**
 * Создание сценария последовательной обработки входных даных заданным набором
 * шагов.
 *
 * Входными данными шага проверки условия будет промежуточный результат
 * выполнения созданного сценария.
 *
 * @see async.Sequence
 * @see async.proc.fold.Scenario
 * @see async.input.IIterator
 * @see async.output.ICollector
 * @see async.ConditionStep
 *
 * @param {!async.Step} handler Шаг обработки.
 * @param {!async.input.IteratorCreator=} opt_iterator Создатель итератора
 *    входного набора данных.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @param {!async.ConditionStep=} opt_condition Шаг проверки условия
 *    продолжения последовательности.
 * @return {!async.proc.fold.Scenario} Созданный сценарий.
 */
async.proc.fold.sequence = function(handler, opt_iterator, opt_collector,
                                    opt_condition) {};


/**
 * Сценарий, задачей которого является обработка элементов входного набора
 * данных с помощью соответсвенного набора шагов и сбор результатов выполнения.
 *
 * В каждый из соответсвующего набора шагов такого сценария будет передан
 * соответсвующий элемент входного набора данных.
 *
 * В качестве накопителя по умолчанию для всех создаваемых сценариев будет
 * выбран создатель собирающего накопителя `async.output.ARRAY_COLLECTOR`.
 *
 * @see async.IStep
 * @see async.input.DataSet
 * @see async.input.IIterator
 * @see async.output.ICollector
 * @see async.output.ArrayCollector
 *
 * @typedef {async.proc.Scenario}
 */
async.proc.zip.Scenario;


/**
 * Создание сценария параллельной обработки каждого элемента входного набора
 * данных с помощью соответсвующих шагов.
 *
 * @see async.Parallel
 * @see async.proc.zip.Scenario
 * @see async.input.IIterator
 * @see async.output.ICollector
 *
 * @param {!Array.<!async.Step>} steps Набор шагов.
 * @param {!async.input.IteratorCreator=} opt_iterator Создатель итератора
 *    входного набора данных.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @return {!async.proc.zip.Scenario} Созданный сценарий.
 */
async.proc.zip.parallel = function(steps, opt_iterator, opt_collector) {};


/**
 * Создание сценария последовательной обработки входных даных заданным набором
 * шагов.
 *
 * Входными данными шага проверки условия будет промежуточный результат
 * выполнения созданного сценария.
 *
 * @see async.Sequence
 * @see async.proc.zip.Scenario
 * @see async.input.IIterator
 * @see async.output.ICollector
 *
 * @param {!Array.<!async.Step>} steps Набор шагов.
 * @param {!async.input.IteratorCreator=} opt_iterator Создатель итератора
 *    входного набора данных.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @param {!async.ConditionStep=} opt_condition Шаг проверки условия
 *    продолжения последовательности.
 * @return {!async.proc.zip.Scenario} Созданный сценарий.
 */
async.proc.zip.sequence = function(steps, opt_iterator, opt_collector,
                                   opt_condition) {};


/**
 * Все, что может выступать в качетсве набора данных.
 *
 * Набор данных определяется возможностью итерировать по его элементам.
 *
 * @see async.input.IIterator
 * @see async.input.IteratorCreator
 *
 * @typedef {async.Input}
 */
async.input.DataSet;


/**
 * Создатель нового итератора по набору данных.
 *
 * Создатель вызывается в контексте сценария и в качетве аргумента создатель
 * принимает входной набор данных шага сценария.
 *
 * Результатом создания является итератор по соотвесвующему набору данных.
 *
 * @typedef {?function(async.input.DataSet):!async.input.IIterator}
 */
async.input.IteratorCreator;


/**
 * Создатель итератора по объекту `Array`.
 *
 * Если входной набор данных не будет являтся массивом, для итератора это будет
 * эквиваленно массиву из одного элемента, за исключением объекта `null` - его
 * эквивалентом для итератора будет пустой массив.
 *
 * @param {async.input.DataSet} input Входной набор данных шага.
 * @return {!async.input.IIterator} Итератор по набору данных.
 */
async.input.ARRAY_ITERATOR = function(input) {};


/**
 * @param {async.input.DataSet} input Входной набор данных шага.
 * @return {!async.input.IIterator} Итератор по набору данных.
 */
async.input.KEY_ITERATOR = function(input) {};


/**
 * Создатель итератора повторяющего входные данные.
 *
 * @param {number} count Количество повторений входных данных
 * @return {!async.input.IteratorCreator}
 */
async.input.REPEAT_ITERATOR = function(count) {};


/**
 * Обертка для объявления создателя итератора в общем виде.
 *
 * @param {function(...)} strictCreator Создатель итератора с уточненными
 *    типами.
 * @return {!async.input.IteratorCreator} Он же, объявленный в общем виде.
 */
async.input.escIterator = function(strictCreator) {};


/**
 * Интерфейс итератора набора данных.
 *
 * @see async.input.DataSet
 *
 * @interface
 */
async.input.IIterator = function() {};


/**
 * Шаг итерации.
 *
 * Результатом итерации является вызов указанного обработчика.
 *
 * При вызове обработчика с одним аргументом его значением являтся экземляр
 * типа данных, соответсвующего набору. Вызов обработчика без аргументов
 * указывает на завершение итерирования и является указанием к уничтожению
 * итератора - уничтожение не происходит автоматически.
 *
 * @see async.input.IIterator#destroy
 *
 * @param {function(async.Input=, async.Context=)} complete Обработчик
 *    результата итерации.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.input.IIterator.prototype.next = function(complete, cancel) {};


/**
 * Уничтожение итератора.
 */
async.input.IIterator.prototype.destroy = function() {};


/**
 * Итератор по массиву реализованному экземпляром стандартного типа `Array`.
 *
 * @constructor
 * @implements {async.input.IIterator}
 */
async.input.NopIterator = function() {};


/**
 * @override
 */
async.input.NopIterator.prototype.next = function(complete, cancel) {};


/**
 * @override
 */
async.input.NopIterator.prototype.destroy = function() {};


/**
 * Итератор по массиву реализованному экземпляром стандартного типа `Array`.
 *
 * @constructor
 * @implements {async.input.IIterator}
 * @param {!Array.<async.Input>} input Входные данные выполнения шага.
 */
async.input.ArrayIterator = function(input) {};


/**
 * @override
 */
async.input.ArrayIterator.prototype.next = function(complete, cancel) {};


/**
 * @override
 */
async.input.ArrayIterator.prototype.destroy = function() {};


/**
 * Итератор повторяющий входные данные.
 *
 * @constructor
 * @implements {async.input.IIterator}
 * @param {async.Input} input Входные данные выполнения шага.
 * @param {number} count Количество повторений входных данных.
 */
async.input.RepeatIterator = function(input, count) {};


/**
 * @override
 */
async.input.RepeatIterator.prototype.next = function(complete, cancel) {};


/**
 * @override
 */
async.input.RepeatIterator.prototype.destroy = function() {};


/**
 * Итератор по массиву реализованному экземпляром стандартного типа `Array`.
 *
 * @constructor
 * @extends {async.input.ArrayIterator}
 * @param {!Object} input Входные данные выполнения шага.
 */
async.input.KeyIterator = function(input) {};


/**
 * @typedef {number}
 */
async.input.cursor.Position;


/**
 * @type {number}
 */
async.input.cursor.START_POSITION;


/**
 * @type {number}
 */
async.input.cursor.STOP_POSITION;


/**
 * @interface
 */
async.input.cursor.ICursor = function() {};


/**
 * @param {async.input.cursor.Position} position Позиция.
 * @param {function(async.input.cursor.Position, !Array.<async.Input>)} complete
 *    Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.input.cursor.ICursor.prototype.next =
    function(position, complete, cancel) {};


/**
 * @constructor
 * @implements {async.input.IIterator}
 * @param {!async.input.cursor.ICursor} cursor Итератор.
 */
async.input.cursor.Iterator = function(cursor) {};


/**
 * @override
 */
async.input.cursor.Iterator.prototype.next = function(complete, cancel) {};


/**
 * Уничтожение итератора.
 */
async.input.cursor.Iterator.prototype.destroy = function() {};


/**
 * @constructor
 * @param {function(async.Input=)} complete Обработчик результата итерации.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.input.cursor.Request = function(complete, cancel) {};


/**
 * @param {async.Input=} opt_output результат.
 */
async.input.cursor.Request.prototype.complete = function(opt_output) {};


/**
 * @param {async.Error} error Ошибка.
 * @param {number=} opt_code Код ошибки.
 */
async.input.cursor.Request.prototype.cancel = function(error, opt_code) {};


/**
 * @constructor
 * @implements {async.input.cursor.ICursor}
 *
 * @param {!async.input.cursor.ICursor} cursor Wrapped cursor.
 */
async.input.cursor.cache.Cursor = function(cursor) {};


/**
 * @override
 */
async.input.cursor.cache.Cursor.prototype.next =
    function(position, complete, cancel) {};


/**
 * @constructor
 *
 * @param {async.input.cursor.Position} position Позиция.
 * @param {function(async.input.cursor.Position, !Array.<async.Input>)} complete
 *    Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.input.cursor.cache.Request = function(position, complete, cancel) {};


/**
 * @param {async.input.cursor.Position} position Позиция.
 * @param {!Array.<async.Input>} data
 */
async.input.cursor.cache.Request.prototype.complete = function(position, data) {};


/**
 * @param {string} error Ошибка.
 * @param {number=} opt_code Код ошибки.
 */
async.input.cursor.cache.Request.prototype.cancel = function(error, opt_code) {};


/**
 * @return {async.input.cursor.Position}
 */
async.input.cursor.cache.Request.prototype.getPosition = function() {};


/**
 * @constructor
 * @implements {async.input.cursor.ICursor}
 *
 * @param {!async.input.cursor.ICursor} cursor Wrapped cursor.
 * @param {!async.Step} filter Фильтр элемента множества.
 * @param {async.Context} context
 * @param {async.Input=} opt_null
 */
async.input.cursor.filter.Cursor = function(cursor, filter, context, opt_null) {};


/**
 * @override
 */
async.input.cursor.filter.Cursor.prototype.next =
    function(position, complete, cancel) {};


/**
 * Коллекционер собирающий результаты в массив, разворациячивая вложенные
 * массивы и игнорируя значение `null`.
 *
 * Данный накопитель удобен при обобщенной работе с множествами.
 *
 * @constructor
 * @implements {async.output.ICollector}
 */
async.output.FlatCollector = function() {};


/**
 * @override
 */
async.output.FlatCollector.prototype.add = function(data) {};


/**
 * @override
 */
async.output.FlatCollector.prototype.get = function() {};


/**
 * @constructor
 * @implements {async.output.ICollector}
 * @param {async.Input=} opt_null
 */
async.output.FilterCollector = function(opt_null) {};


/**
 * @override
 */
async.output.FilterCollector.prototype.add = function(data) {};


/**
 * @override
 */
async.output.FilterCollector.prototype.get = function() {};


/**
 * Интерфейс коллекционера результатов обработки.
 *
 * Объекты реализующие данный интерфейс могут выступать в качестве накопителей
 * и обработчиков результатов выполнения шагов обрабатывающих сценариев.
 *
 * @see async.output.CollectorCreator
 * @see async.proc.Scenario
 *
 * @interface
 */
async.output.ICollector = function() {};


/**
 * Добавление результата выполнения шага в коллекцию.
 *
 * @param {async.Output} data Результат выполнения шага.
 * @param {async.Context} context Контекст выполнения шага.
 */
async.output.ICollector.prototype.add = function(data, context) {};


/**
 * Возвращение текущего результата.
 *
 * @return {async.Output} Результат накопления.
 */
async.output.ICollector.prototype.get = function() {};


/**
 * Создатель коллекционера результатов обработки.
 *
 * Создатель вызывается в контексте сценария и получает в качетве аргумента
 * входные данные соотвествующего шага для модификации коллекционера.
 *
 * Резузльтатом создания является объект реализующий интерфейс колекционера
 * результата, для использования в сценраии.
 *
 * @see async.Input
 * @see async.output.ICollector
 * @see async.proc.Scenario
 *
 * @typedef {?function(async.Input):!async.output.ICollector}
 */
async.output.CollectorCreator;


/**
 * Обертка для объявления создателя накопителя в общем виде.
 *
 * @param {function(...)} strictCreator Создатель накопителя с уточненными
 *    типами.
 * @return {!async.output.CollectorCreator} Он же, объявленный в общем виде.
 */
async.output.escCollector = function(strictCreator) {};


/**
 * Создатель коллекционера игнорирующего результаты.
 *
 * @param {async.Input} input Входные данные шага.
 * @return {!async.output.ICollector} Коллекционер результата.
 */
async.output.NOP_COLLECTOR = function(input) {};


/**
 * Создатель коллекционера игнорирующего результаты.
 *
 * @param {async.Input} input Входные данные шага.
 * @return {!async.output.ICollector} Коллекционер результата.
 */
async.output.NULL_COLLECTOR = function(input) {};


/**
 * Создатель коллекционера собирающего результаты в массив.
 *
 * Не зависит от входных данных.
 *
 * @param {async.Input} input Входные данные шага.
 * @return {!async.output.ICollector} Коллекционер результата.
 */
async.output.ARRAY_COLLECTOR = function(input) {};


/**
 * Создатель коллекционера собирающего результаты в массив игнорирующего `null`
 * и разврачивающего вложенные.
 *
 * Не зависит от входных данных.
 *
 * @param {async.Input} input Входные данные шага.
 * @return {!async.output.ICollector} Коллекционер результата.
 */
async.output.FLAT_COLLECTOR = function(input) {};


/**
 * Создатель коллекционера собирающего последнйи результат.
 *
 * Не зависит от входных данных.
 *
 * @param {async.Input} input Входные данные шага.
 * @return {!async.output.ICollector} Коллекционер результата.
 */
async.output.ONE_COLLECTOR = function(input) {};


/**
 * Создатель коллекционера.
 *
 * @param {async.Input} input Входные данные шага.
 * @return {!async.output.ICollector} Коллекционер результата.
 */
async.output.AND_COLLECTOR = function(input) {};


/**
 * @param {async.Input=} opt_null
 * @return {!async.output.CollectorCreator} Коллекционер результата.
 */
async.output.FILTER_COLLECTOR = function(opt_null) {};


/**
 * Коллекционер игнорирующий результаты шагов сценария.
 *
 * Результатом накопления данного коллекционера является переданное в
 * конструктор значение.
 *
 * @constructor
 * @implements {async.output.ICollector}
 * @param {async.Input} input Входные данные выполнения шага.
 */
async.output.NopCollector = function(input) {};


/**
 * @override
 */
async.output.NopCollector.prototype.add = function(data) {};


/**
 * @override
 */
async.output.NopCollector.prototype.get = function() {};


/**
 * Коллекционер игнорирующий результаты шагов сценария.
 *
 * Результатом накопления данного коллекционера является `null`.
 *
 * @constructor
 * @implements {async.output.ICollector}
 */
async.output.NullCollector = function() {};


/**
 * @override
 */
async.output.NullCollector.prototype.add = function(data) {};


/**
 * @override
 */
async.output.NullCollector.prototype.get = function() {};


/**
 * Коллекционер собирающий результаты в массив.
 *
 * @constructor
 * @implements {async.output.ICollector}
 */
async.output.ArrayCollector = function() {};


/**
 * @override
 */
async.output.ArrayCollector.prototype.add = function(data) {};


/**
 * @override
 */
async.output.ArrayCollector.prototype.get = function() {};


/**
 * Коллекционер сохраняющий только последний результат.
 *
 * @constructor
 * @implements {async.output.ICollector}
 */
async.output.OneCollector = function() {};


/**
 * @override
 */
async.output.OneCollector.prototype.add = function(data) {};


/**
 * @override
 */
async.output.OneCollector.prototype.get = function() {};


/**
 * @constructor
 * @implements {async.output.ICollector}
 */
async.output.AndCollector = function() {};


/**
 * @override
 */
async.output.AndCollector.prototype.add = function(data) {};


/**
 * @override
 */
async.output.AndCollector.prototype.get = function() {};


/**
 * @param {...*} var_args Аргументы для вывода.
 * @return {!async.Step} Шаг вывода в консоль.
 */
async.console.info = function(var_args) {};


/**
 * @param {...*} var_args Аргументы для вывода.
 * @return {!async.Step} Шаг вывода в консоль.
 */
async.console.warn = function(var_args) {};


/**
 * @param {...*} var_args Аргументы для вывода.
 * @return {!async.Step} Шаг вывода в консоль.
 */
async.console.error = function(var_args) {};


/**
 * @param {...*} var_args Аргументы для вывода.
 * @return {!async.Step} Шаг вывода в консоль.
 */
async.console.log = function(var_args) {};


/**
 * @param {...*} var_args Аргументы для вывода.
 * @return {!async.Step} Шаг вывода в консоль.
 */
async.console.expand = function(var_args) {};


/**
 * @namespace
 */
var ds = {};


/**
 * @namespace
 */
ds.queue = {};


/**
 * @interface
 */
ds.IDataItem = function() {};


/**
 * @return {*} Данные.
 */
ds.IDataItem.prototype.get = function() {};


/**
 * @interface
 */
ds.IDataSet = function() {};


/**
 * @param {(number|string)=} opt_type Тип итератора.
 * @return {!ds.IIterator} Итератор.
 */
ds.IDataSet.prototype.getIterator = function(opt_type) {};


/**
 * @param {!ds.IDataItem} item Элемент для удаления.
 * @return {!ds.IDataItem} Удаленный элемент.
 */
ds.IDataSet.prototype.remove = function(item) {};


/**
 *
 */
ds.IDataSet.prototype.destroy = function() {};


/**
 * @interface
 */
ds.IIterator = function() {};


/**
 * Имеется ли следующий элемент.
 *
 * @return {boolean} Результат проверки.
 */
ds.IIterator.prototype.hasNext = function() {};


/**
 * @param {!ds.IDataItem} item Элемент для проверки.
 * @return {boolean} Результат проверки.
 */
ds.IIterator.prototype.isNext = function(item) {};


/**
 * @return {ds.IDataItem} Следующий элемент.
 */
ds.IIterator.prototype.next = function() {};


/**
 *
 */
ds.IIterator.prototype.destroy = function() {};


/**
 * @constructor
 * @implements {ds.IDataItem}
 * @param {*} data Данные.
 */
ds.queue.QueueItem = function(data) {

  /**
   * @type {!ds.queue.QueueItem}
   */
  this.next;


  /**
   * @type {!ds.queue.QueueItem}
   */
  this.prev;

};


/**
 * @inheritDoc
 */
ds.queue.QueueItem.prototype.get = function() {};


/**
 * @constructor
 * @implements {ds.IIterator}
 * @param {!ds.queue.Queue} queue Очередь.
 */
ds.queue.QueueIterator = function(queue) {};


/**
 * @inheritDoc
 */
ds.queue.QueueIterator.prototype.hasNext = function() {};


/**
 * @inheritDoc
 */
ds.queue.QueueIterator.prototype.isNext = function(item) {};


/**
 * @inheritDoc
 */
ds.queue.QueueIterator.prototype.next = function() {};


/**
 * @inheritDoc
 */
ds.queue.QueueIterator.prototype.destroy = function() {};


/**
 * @constructor
 * @implements {ds.IDataSet}
 */
ds.queue.Queue = function() {

  /**
   * @type {number}
   */
  this.length;

};


/**
 * @inheritDoc
 */
ds.queue.Queue.prototype.getIterator = function(opt_type) {};


/**
 * @inheritDoc
 */
ds.queue.Queue.prototype.destroy = function() {};


/**
 * @param {!ds.queue.QueueIterator} iterator Итератор.
 */
ds.queue.Queue.prototype.addActiveIterator = function(iterator) {};


/**
 * @param {!ds.queue.QueueIterator} iterator Итератор.
 */
ds.queue.Queue.prototype.removeActiveIterator = function(iterator) {};


/**
 * @return {ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.getFirst = function() {};


/**
 * @return {ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.getLast = function() {};


/**
 * @param {!ds.queue.QueueItem} target Элемент очереди.
 * @return {ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.getBefore = function(target) {};


/**
 * @param {!ds.queue.QueueItem} target Элемент очереди.
 * @return {ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.getAfter = function(target) {};


/**
 * @param {!ds.queue.QueueItem} item Элемент очереди.
 * @param {!ds.queue.QueueItem} target Элемент очереди.
 * @return {!ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.addBefore = function(item, target) {};


/**
 * @param {!ds.queue.QueueItem} item Элемент очереди.
 * @param {!ds.queue.QueueItem} target Элемент очереди.
 * @return {!ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.addAfter = function(item, target) {};


/**
 * @param {*} data Элемент очереди.
 * @return {!ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.push = function(data) {};


/**
 * @param {!ds.queue.QueueItem|*} data Элемент очереди.
 * @return {!ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.unshift = function(data) {};


/**
 * @inheritDoc
 */
ds.queue.Queue.prototype.remove = function(item) {};


/**
 * @return {*} Элемент очереди.
 */
ds.queue.Queue.prototype.shift = function() {};


/**
 * @return {*} Элемент очереди.
 */
ds.queue.Queue.prototype.pop = function() {};


/**
 * @return {*} Элемент очереди.
 */
ds.queue.Queue.prototype.head = function() {};


/**
 * @return {*} Элемент очереди.
 */
ds.queue.Queue.prototype.tail = function() {};


/**
 * @param {function(*)} callback Обработчик элемента очереди.
 */
ds.queue.Queue.prototype.map = function(callback) {};


/**
 * @namespace
 */
var thrift = {};


/**
 * @namespace
 */
thrift.protocol = {};


/**
 * @namespace
 */
thrift.definition = {};


/**
 * @namespace
 */
thrift.io = {};


/**
 * @namespace
 */
thrift.io.http = {};


/**
 * @namespace
 */
thrift.io.tcp = {};


/**
 * @typedef {*}
 */
thrift.Value;


/**
 * @typedef {?function(number,
 *    !thrift.protocol.IProtocol):thrift.IPacketHandler}
 */
thrift.HandlerBuilder;


/**
 * @param {number} type
 * @param {!thrift.protocol.IProtocol} protocol
 * @return {thrift.IPacketHandler}
 */
thrift.handlerBuilder = function(type, protocol) {};


/**
 * @param {!thrift.protocol.IProtocol} protocol
 * @param {number} id
 * @param {string} name
 * @param {!Array.<thrift.Value>} args
 * @return {!Buffer}
 */
thrift.encodeCall = function(protocol, id, name, args) {};


/**
 * @param {!thrift.protocol.IProtocol} protocol
 * @param {number} id
 * @param {string} name
 * @param {thrift.Value} data
 * @return {!Buffer}
 */
thrift.encodeReply = function(protocol, id, name, data) {};


/**
 * @param {!thrift.protocol.IProtocol} protocol
 * @param {!number} id
 * @param {!string} name
 * @param {!String} message
 * @param {number=} opt_code
 * @return {!Buffer}
 */
thrift.encodeException =
    function(protocol, id, name, message, opt_code) {};


/**
 * @param {thrift.Value} field
 * @param {!thrift.definition.FullType} fullType
 * @param {!thrift.ISchema} idl
 * @return {thrift.Value}
 */
thrift.convertNestedStructure = function(field, fullType, idl) {};


/**
 * @param {string} type structure class name.
 * @param {!Object} structure thriftStructure
 * @param {!thrift.ISchema} idl
 * @return {!Object}
 */
thrift.convertStructure = function(type, structure, idl) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {!thrift.Value} value
 * @param {!thrift.definition.FullType} fullType
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.serializeValue = function(collector, value, fullType, protocol) {};


/**
 * @interface
 */
thrift.IPacketHandler = function() {};


/**
 * Shifts cursor and returns is's new position.
 *
 * @param {!thrift.Cursor} cursor object.
 * @param {!Buffer} chunk Data packet.
 * @return {boolean} Flag of packet handling.
 */
thrift.IPacketHandler.prototype.process = function(cursor, chunk) {};


/**
 * @return {thrift.Value}
 */
thrift.IPacketHandler.prototype.get = function() {};


/**
 * @interface
 */
thrift.IValueKeeper = function() {};


/**
 * @return {boolean}
 */
thrift.IValueKeeper.prototype.isComplete = function() {};


/**
 * @param {thrift.Value} value
 */
thrift.IValueKeeper.prototype.applyData = function(value) {};


/**
 * @return {thrift.Value} value
 */
thrift.IValueKeeper.prototype.get = function() {};


/**
 * @return {number} type
 */
thrift.IValueKeeper.prototype.getType = function() {};


/**
 * @param {!thrift.Cursor} cursor object.
 * @param {!Buffer} chunk Data packet.
 */
thrift.IValueKeeper.prototype.processHeader = function(cursor, chunk) {};


/**
 * @return {boolean} Flag of packet handling.
 */
thrift.IValueKeeper.prototype.isHeaderComplete = function() {};


/**
 * @interface
 */
thrift.ISchema = function() {};


/**
 * @param {string} type
 * @param {!Object} args
 * @return {!Object}
 */
thrift.ISchema.prototype.createStructure = function(type, args) {};


/**
 * @param {string} type
 * @return {thrift.definition.Structure}
 */
thrift.ISchema.prototype.getStructureDefinition = function(type) {};


/**
 * @param {string} name
 * @return {thrift.definition.Method}
 */
thrift.ISchema.prototype.getMethodDefinition = function(name) {};


/**
 * Global cursor.
 * @constructor
 */
thrift.Cursor = function() {};


/**
 * @return {number} current cursor position.
 */
thrift.Cursor.prototype.getPosition = function() {};


/**
 * @param {number} value increment current position on value.
 */
thrift.Cursor.prototype.incrPosition = function(value) {};


/**
 * @return {boolean}
 */
thrift.Cursor.prototype.isParsed = function() {};


/**
 * set this.__isParsed in false, flag - finish data.
 */
thrift.Cursor.prototype.breakParsing = function() {};


/**
 * @constructor
 *
 * @param {string} name
 * @param {number} type
 * @param {number} seqid
 * @param {thrift.Value} value
 */
thrift.Message = function(name, type, seqid, value) {};


/**
 * @return {thrift.Value}
 */
thrift.Message.prototype.getValue = function() {};


/**
 * @return {number}
 */
thrift.Message.prototype.getType = function() {};


/**
 * @return {string}
 */
thrift.Message.prototype.getName = function() {};


/**
 * @return {number}
 */
thrift.Message.prototype.getId = function() {};


/**
 * @return {boolean}
 */
thrift.Message.prototype.isException = function() {};


/**
 * @constructor
 * @param {number} type
 * @param {number} id
 * @param {thrift.Value} value
 */
thrift.Field = function(type, id, value) {};


/**
 * @return {thrift.Value}
 */
thrift.Field.prototype.getValue = function() {};


/**
 * @return {number}
 */
thrift.Field.prototype.getType = function() {};


/**
 * @return {number}
 */
thrift.Field.prototype.getId = function() {};


/**
 * @constructor
 * @param {!thrift.protocol.IProtocol}  protocol
 */
thrift.Parser = function(protocol) {};


/**
 * @param {!Buffer} chunk
 * @return {!Array.<!thrift.Message>}
 */
thrift.Parser.prototype.process = function(chunk) {};


/**
 * @constructor
 * @param {!thrift.io.IClientTransport} transport
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.io.Client = function(transport, protocol) {};


/**
 * @param {!Buffer} payload Объект ответа.
 */
thrift.io.Client.prototype.process = function(payload) {};


/**
 * @param {string} name
 * @param {!Array.<thrift.Value>} args
 * @param {!async.CompleteHandler} complete
 * @param {!async.ErrorHandler} cancel
 */
thrift.io.Client.prototype.request = function(name, args, complete, cancel) {};


/**
 *
 */
thrift.io.Client.prototype.destroy = function() {};


/**
 * @constructor
 * @implements {thrift.io.IClientTransport}
 * @param {number} port Connection port.
 * @param {string=} opt_host Хост Connection host.
 */
thrift.io.tcp.Client = function(port, opt_host) {};


/**
 * @type {number}
 */
thrift.io.tcp.Client.RECONNECT_TIMEOUT;


/**
 * @inheritDoc
 */
thrift.io.tcp.Client.prototype.init = function(client) {

  /**
   * @param {!Buffer} data
   */
  this.__handleData = function(data) {};

};


/**
 * @inheritDoc
 */
thrift.io.tcp.Client.prototype.write = function(bytes) {};


/**
 * @inheritDoc
 */
thrift.io.tcp.Client.prototype.destroy = function() {};


/**
 * @interface
 */
thrift.io.IClientTransport = function() {};


/**
 * @param {!Buffer} bytes
 */
thrift.io.IClientTransport.prototype.write = function(bytes) {};


/**
 * @param {!thrift.io.Client} client
 */
thrift.io.IClientTransport.prototype.init = function(client) {};


/**
 *
 */
thrift.io.IClientTransport.prototype.destroy = function() {};


/**
 * @constructor
 * @implements {thrift.IPacketHandler}
 * @param {number} type
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.SimpleHandler = function(type, protocol) {};


/**
 * @inheritDoc
 */
thrift.SimpleHandler.prototype.get = function() {};


/**
 * @inheritDoc
 */
thrift.SimpleHandler.prototype.process = function(cursor, chunk) {};


/**
 *
 * @constructor
 * @implements {thrift.IPacketHandler}
 * @param {!thrift.protocol.IProtocol} protocol
 * @param {!thrift.HandlerBuilder} valueHandlerBuilder
 * @param {!thrift.IValueKeeper} valueKeeper
 */
thrift.IncludedHandler = function(protocol, valueHandlerBuilder,
                                  valueKeeper) {};


/**
 * @inheritDoc
 */
thrift.IncludedHandler.prototype.process = function(cursor, chunk) {};


/**
 * @inheritDoc
 */
thrift.IncludedHandler.prototype.get = function() {};


/**
 * TODO: remove
 *
 * @enum {number}
 */
thrift.definition.ExceptionType = {
  'UNKNOWN': 0,
  'UNKNOWN_METHOD': 1,
  'INVALID_MESSAGE_TYPE': 2,
  'WRONG_METHOD_NAME': 3,
  'BAD_SEQUENCE_ID': 4,
  'MISSING_RESULT': 5,
  'INTERNAL_ERROR': 6,
  'PROTOCOL_ERROR': 7,
  'INVALID_TRANSFORM': 8,
  'INVALID_PROTOCOL': 9,
  'UNSUPPORTED_CLIENT_TYPE': 10
};


/**
 * @enum {number}
 */
thrift.definition.MessageType = {
  CALL: 1,
  REPLY: 2,
  EXCEPTION: 3
};


/**
 * @enum {number}
 */
thrift.definition.Type = {
  'NOP': -1,
  'STOP': 0,
  'VOID': 1,
  'BOOL': 2,
  'BYTE': 3,
  'I08': 3,
  'DOUBLE': 4,
  'I16': 6,
  'I32': 8,
  'I64': 10,
  'STRING': 11,
  'UTF7': 11,
  'STRUCT': 12,
  'MAP': 13,
  'SET': 14,
  'LIST': 15,
  'UTF8': 16,
  'UTF16': 17
};


/**
 * Wrapper for types;
 *
 * @constructor
 * @param {thrift.definition.Type|string} type
 * @param {!thrift.definition.FullType|string|thrift.definition.Type=} opt_vType
 * @param {!thrift.definition.FullType|string|thrift.definition.Type=} opt_kType
 */
thrift.definition.FullType = function(type, opt_vType, opt_kType) {};


/**
 * @type {!thrift.definition.FullType}
 */
thrift.definition.FullType.NULL;


/**
 * @return {number}
 */
thrift.definition.FullType.prototype.getType = function() {};


/**
 * @return {!thrift.definition.FullType}
 */
thrift.definition.FullType.prototype.getKeyType = function() {};


/**
 * @return {!thrift.definition.FullType}
 */
thrift.definition.FullType.prototype.getValueType = function() {};


/**
 * @return {string}
 */
thrift.definition.FullType.prototype.getStructType = function() {};


/**
 * @constructor
 * @param {string} name
 * @param {number} id
 * @param {thrift.definition.Type|string} type
 * @param {!thrift.definition.FullType|thrift.definition.Type|string=} opt_vType
 * @param {!thrift.definition.FullType|thrift.definition.Type|string=} opt_kType
 */
thrift.definition.Field = function(name, id, type, opt_vType, opt_kType) {};


/**
 * @return {!string}
 */
thrift.definition.Field.prototype.getName = function() {};


/**
 * @return {number}
 */
thrift.definition.Field.prototype.getId = function() {};


/**
 * @return {!thrift.definition.FullType}
 */
thrift.definition.Field.prototype.getFullType = function() {};


/**
 * @return {number}
 */
thrift.definition.Field.prototype.getType = function() {};


/**
 * @constructor
 *
 * @param {!Object.<number, !thrift.definition.Field>} parameters
 * @param {!thrift.definition.FullType=} opt_returnType
 */
thrift.definition.Method = function(parameters, opt_returnType) {};


/**
 * @param {number|string} id
 * @return {thrift.definition.Field}
 */
thrift.definition.Method.prototype.getParameter = function(id) {};


/**
 * @return {!thrift.definition.FullType}
 */
thrift.definition.Method.prototype.getReturnType = function() {};


/**
 * @constructor
 *
 * @param {!Object.<string, !thrift.definition.Field>} fields
 */
thrift.definition.Structure = function(fields) {};


/**
 * @param {string} id
 * @return {thrift.definition.FullType}
 */
thrift.definition.Structure.prototype.getTypeById = function(id) {};


/**
 * @param {string} name
 * @return {thrift.definition.FullType}
 */
thrift.definition.Structure.prototype.getTypeByName = function(name) {};


/**
 * @param {string} name
 * @return {number}
 */
thrift.definition.Structure.prototype.getIdByName = function(name) {};


/**
 * @constructor
 * @implements {thrift.protocol.IProtocol}
 * @param {!thrift.ISchema} idl
 */
thrift.protocol.Binary = function(idl) {};


/**
 * @type {number} 0x80010000
 */
thrift.protocol.Binary.prototype.VERSION;


/**
 * @type {number} -65536
 */
thrift.protocol.Binary.prototype.VERSION_MASK;


/**
 * @type {number}
 */
thrift.protocol.Binary.prototype.TYPE_MASK;


/**
 * @return {!thrift.ISchema}
 */
thrift.protocol.Binary.prototype.getIdl = function() {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeMessageHeader =
    function(collector, methodName, type, seqid) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.serializeStructure =
    function(collector, struct, type) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.serializeMap =
    function(collector, map, keyInfo, valInfo) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.serializeArray =
    function(collector, array, fullValueType) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeFieldHeader =
    function(collector, type, id) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeFieldStop = function(collector) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeMapHeader =
    function(collector, ktype, vtype, size) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeListHeader =
    function(collector, etype, size) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeSetHeader =
    function(collector, etype, size) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeBool = function(collector, bool) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeByte = function(collector, value) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeI16 = function(collector, value) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeI32 = function(collector, value) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeI64 = function(collector, value) {};


/**
 *
 *
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeDouble = function(collector, double) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeString = function(collector, value) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.readBool = function(cursor, chunk) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.readByte = function(cursor, chunk) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.readI16 = function(cursor, chunk) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.readI32 = function(cursor, chunk) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.readI64 = function(cursor, chunk) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.readDouble = function(cursor, chunk) {};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.readString = function(cursor, chunk) {};


/**
 * @param {number} type
 * @param {!thrift.protocol.IProtocol} protocol
 * @return {!thrift.IPacketHandler}
 */
thrift.protocol.MAP_HANDLER = function(type, protocol) {};


/**
 * @param {number} type
 * @param {!thrift.protocol.IProtocol} protocol
 * @return {!thrift.IPacketHandler}
 */
thrift.protocol.ARRAY_HANDLER = function(type, protocol) {};


/**
 * @param {number} type
 * @param {!thrift.protocol.IProtocol} protocol
 * @return {!thrift.IPacketHandler}
 */
thrift.protocol.FIELD_HANDLER = function(type, protocol) {};


/**
 * @param {number} type
 * @param {!thrift.protocol.IProtocol} protocol
 * @return {!thrift.IPacketHandler}
 */
thrift.protocol.STRUCTURE_HANDLER = function(type, protocol) {};


/**
 * @param {!thrift.protocol.IProtocol} protocol
 * @return {!thrift.IPacketHandler}
 */
thrift.protocol.MESSAGE_HANDLER = function(protocol) {};


/**
 * @interface
 */
thrift.protocol.IProtocol = function() {};


/**
 * @return {!thrift.ISchema}
 */
thrift.protocol.IProtocol.prototype.getIdl = function() {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {!Object} userStructure
 * @param {!string} type
 */
thrift.protocol.IProtocol.prototype.serializeStructure =
    function(collector, userStructure, type) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {!Object} array
 * @param {!thrift.definition.FullType} valInfo
 */
thrift.protocol.IProtocol.prototype.serializeArray =
    function(collector, array, valInfo) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {!Object} map
 * @param {!thrift.definition.FullType} keyInfo
 * @param {!thrift.definition.FullType} valInfo
 */
thrift.protocol.IProtocol.prototype.serializeMap =
    function(collector, map, keyInfo, valInfo) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {string} methodName
 * @param {number} type
 * @param {number} seqid
 */
thrift.protocol.IProtocol.prototype.writeMessageHeader =
    function(collector, methodName, type, seqid) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} type
 * @param {number} id
 */
thrift.protocol.IProtocol.prototype.writeFieldHeader =
    function(collector, type, id) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 */
thrift.protocol.IProtocol.prototype.writeFieldStop = function(collector) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} ktype
 * @param {number} vtype
 * @param {number} size
 */
thrift.protocol.IProtocol.prototype.writeMapHeader =
    function(collector, ktype, vtype, size) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} type
 * @param {number} size
 */
thrift.protocol.IProtocol.prototype.writeListHeader =
    function(collector, type, size) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} type
 * @param {number} size
 */
thrift.protocol.IProtocol.prototype.writeSetHeader =
    function(collector, type, size) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {boolean} value
 */
thrift.protocol.IProtocol.prototype.writeBool = function(collector, value) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} value
 */
thrift.protocol.IProtocol.prototype.writeByte = function(collector, value) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} value
 */
thrift.protocol.IProtocol.prototype.writeI16 = function(collector, value) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} value
 */
thrift.protocol.IProtocol.prototype.writeI32 = function(collector, value) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {thrift.protocol.Int64|number} value
 */
thrift.protocol.IProtocol.prototype.writeI64 = function(collector, value) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} value
 */
thrift.protocol.IProtocol.prototype.writeDouble = function(collector, value) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {string} value
 */
thrift.protocol.IProtocol.prototype.writeString = function(collector, value) {};


/**
 * @param {!thrift.Cursor} cursor
 * @param {!Buffer} chunk
 * @return {boolean}
 */
thrift.protocol.IProtocol.prototype.readBool = function(cursor, chunk) {};


/**
 * @param {!thrift.Cursor} cursor
 * @param {!Buffer} chunk
 * @return {number}
 */
thrift.protocol.IProtocol.prototype.readByte = function(cursor, chunk) {};


/**
 * @param {!thrift.Cursor} cursor
 * @param {!Buffer} chunk
 * @return {number}
 */
thrift.protocol.IProtocol.prototype.readI16 = function(cursor, chunk) {};


/**
 * @param {!thrift.Cursor} cursor
 * @param {!Buffer} chunk
 * @return {number}
 */
thrift.protocol.IProtocol.prototype.readI32 = function(cursor, chunk) {};


/**
 * @param {!thrift.Cursor} cursor
 * @param {!Buffer} chunk
 * @return {thrift.protocol.Int64}
 */
thrift.protocol.IProtocol.prototype.readI64 = function(cursor, chunk) {};


/**
 * @param {!thrift.Cursor} cursor
 * @param {!Buffer} chunk
 * @return {number}
 */
thrift.protocol.IProtocol.prototype.readDouble = function(cursor, chunk) {};


/**
 * @param {!thrift.Cursor} cursor
 * @param {!Buffer} chunk
 * @return {string}
 */
thrift.protocol.IProtocol.prototype.readString = function(cursor, chunk) {};


/**
 * @constructor
 *
 * @param {!Buffer|number} int64
 */
thrift.protocol.Int64 = function(int64) {};


/**
 * @type {number}
 */
thrift.protocol.Int64.prototype.MAX_VALUE;


/**
 * @param {Buffer} chunk
 * @return {number}
 */
thrift.protocol.Int64.prototype.binToDec = function binToDec(chunk) {};


/**
 * @param {number} decNumber
 * @return {!Buffer}
 */
thrift.protocol.Int64.prototype.decToBin = function(decNumber) {};


/**
 * @return {!Buffer}
 */
thrift.protocol.Int64.prototype.getBuffer = function() {};


/**
 * @return {number}
 */
thrift.protocol.Int64.prototype.getNumber = function() {};


/**
 * @constructor
 */
thrift.protocol.ChunkCollector = function() {};


/**
 * @param {!Buffer} chunk
 */
thrift.protocol.ChunkCollector.prototype.push = function(chunk) {};


/**
 * @return {!Array.<!Buffer>}
 */
thrift.protocol.ChunkCollector.prototype.getChunks = function() {};


/**
 * @return {!number}
 */
thrift.protocol.ChunkCollector.prototype.getLength = function() {};


/**
 * @return {!Buffer}
 */
thrift.protocol.ChunkCollector.prototype.getTotalBytes = function() {};


/**
 * @constructor
 * @implements {thrift.IValueKeeper}
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.protocol.ArrayKeeper = function(protocol) {};


/**
 * @inheritDoc
 */
thrift.protocol.ArrayKeeper.prototype.isHeaderComplete = function() {};


/**
 * @inheritDoc
 */
thrift.protocol.ArrayKeeper.prototype.processHeader = function(cursor, chunk) {};


/**
 * @inheritDoc
 */
thrift.protocol.ArrayKeeper.prototype.isComplete = function() {};


/**
 * @inheritDoc
 */
thrift.protocol.ArrayKeeper.prototype.applyData = function(value) {};


/**
 * @inheritDoc
 */
thrift.protocol.ArrayKeeper.prototype.get = function() {};


/**
 * @return {number}
 */
thrift.protocol.ArrayKeeper.prototype.getType = function() {};


/**
 * @return {number}
 */
thrift.protocol.ArrayKeeper.prototype.getLength = function() {};


/**
 * @implements {thrift.IValueKeeper}
 * @constructor
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.protocol.FieldKeeper = function(protocol) {};


/**
 * @inheritDoc
 */
thrift.protocol.FieldKeeper.prototype.processHeader = function(cursor, chunk) {};


/**
 * @inheritDoc
 */
thrift.protocol.FieldKeeper.prototype.isHeaderComplete = function() {};


/**
 * @inheritDoc
 */
thrift.protocol.FieldKeeper.prototype.applyData = function(value) {};


/**
 * @inheritDoc
 */
thrift.protocol.FieldKeeper.prototype.isComplete = function() {};


/**
 * @inheritDoc
 */
thrift.protocol.FieldKeeper.prototype.get = function() {};


/**
 * @return {number}
 */
thrift.protocol.FieldKeeper.prototype.getType = function() {};


/**
 * @return {number}
 */
thrift.protocol.FieldKeeper.prototype.getId = function() {};


/**
 * @constructor
 * @implements {thrift.IValueKeeper}
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.protocol.MapKeeper = function(protocol) {};


/**
 * @inheritDoc
 */
thrift.protocol.MapKeeper.prototype.isHeaderComplete = function() {};


/**
 * @inheritDoc
 */
thrift.protocol.MapKeeper.prototype.processHeader = function(cursor, chunk) {};


/**
 * @inheritDoc
 */
thrift.protocol.MapKeeper.prototype.applyData = function(value) {};


/**
 * @inheritDoc
 */
thrift.protocol.MapKeeper.prototype.isComplete = function() {};


/**
 * @inheritDoc
 */
thrift.protocol.MapKeeper.prototype.get = function() {};


/**
 * @return {number}
 */
thrift.protocol.MapKeeper.prototype.getType = function() {};


/**
 *
 * @implements {thrift.IValueKeeper}
 * @constructor
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.protocol.MessageKeeper = function(protocol) {};


/**
 * @inheritDoc
 */
thrift.protocol.MessageKeeper.prototype.isHeaderComplete = function() {};


/**
 * @inheritDoc
 */
thrift.protocol.MessageKeeper.prototype.processHeader =
    function(cursor, chunk) {};


/**
 * @inheritDoc
 */
thrift.protocol.MessageKeeper.prototype.get = function() {};


/**
 * @inheritDoc
 */
thrift.protocol.MessageKeeper.prototype.isComplete = function() {};


/**
 * @inheritDoc
 */
thrift.protocol.MessageKeeper.prototype.applyData = function(structure) {};


/**
 * @inheritDoc
 */
thrift.protocol.MessageKeeper.prototype.getType = function() {};


/**
 * @return {number}
 */
thrift.protocol.MessageKeeper.prototype.getId = function() {};


/**
 * @return {string}
 */
thrift.protocol.MessageKeeper.prototype.getName = function() {};


/**
 * @constructor
 * @implements {thrift.IValueKeeper}
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.protocol.StructureKeeper = function(protocol) {};


/**
 * @inheritDoc
 */
thrift.protocol.StructureKeeper.prototype.processHeader =
    function(cursor, chunk) {};


/**
 * @inheritDoc
 */
thrift.protocol.StructureKeeper.prototype.isHeaderComplete = function() {};


/**
 * @inheritDoc
 */
thrift.protocol.StructureKeeper.prototype.applyData = function(field) {};


/**
 * @inheritDoc
 */
thrift.protocol.StructureKeeper.prototype.isComplete = function() {};


/**
 * @inheritDoc
 */
thrift.protocol.StructureKeeper.prototype.get = function() {};


/**
 * @inheritDoc
 */
thrift.protocol.StructureKeeper.prototype.getType = function() {};




