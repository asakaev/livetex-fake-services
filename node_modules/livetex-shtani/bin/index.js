#! /usr/bin/node
var util = require('util');
var http = require('http');
var net = require('net');

/**
 * @namespace
 */
util.arr = {};


/**
 * @namespace
 */
util.config = {};


/**
 * @namespace
 */
util.cli = {};


/**
 * @namespace
 */
util.fn = {};


/**
 * @namespace
 */
util.hash = {};


/**
 * @namespace
 */
util.io = {};


/**
 * @namespace
 */
util.io.async = {};


/**
 * @namespace
 */
util.log = {};


/**
 * @namespace
 */
util.obj = {};


/**
 * @namespace
 */
util.uid = {};


/**
 * @namespace
 */
util.collector = {};


/**
 * @type {number}
 */
util.ENUM_SEED = Math.random();


/**
 * Clones an object
 *
 * @param {*} value Value to clone.
 * @return {*} Copy of an object.
 */
util.clone = function(value) {
  if (value instanceof Object) {
    return util.obj.clone(value);
  }

  return value;
};


/**
 * Compares two objects
 *
 * @param {*} first Object to compare.
 * @param {*} second Object to compare.
 * @return {boolean} Result of comparison.
 */
util.equals = function(first, second) {
  if (first === second) {
    return true;
  } else if (first instanceof Object && second instanceof Object) {
    return util.obj.equals(first, second);
  }

  return false;
};


/**
 * Encodes object to JSON.
 *
 * @param {*} object The object to code.
 * @return {string} JSON string.
 */
util.encodeJson = function(object) {
  try {
    return JSON.stringify(object) || '';
  } catch (error) {
    console.warn('JSON encoding error: "' +
        error.message + '". [util.encodeJson]', object);
  }

  return '';
};


/**
 * Converts JSON to object.
 *
 * @param {string} data JSON string..
 * @return {*} JSON object.
 */
util.decodeJson = function(data) {
  try {
    if (data !== '') {
      return JSON.parse(data);
    }
  } catch (error) {
    console.warn('JSON parsing error: "' +
        error.message + '". [util.decodeJson]', data);
  }

  return null;
};


/**
 * Encodes string to base64 format.
 *
 * @param {string} string Строка.
 * @param {boolean=} opt_forUrl Флаг URL-безопасного кодирования.
 * @return {string} Закодированная строка.
 */
util.encodeBase64 = function(string, opt_forUrl) {
  var result = (new Buffer(string)).toString('base64');

  if (opt_forUrl) {
    result = result.replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/\=+\s*$/g, '');
  }

  return result;
};


/**
 * Converts base64 to ordinary string.
 *
 * @param {string} string Base64 string.
 * @param {boolean=} opt_forUrl Flag for URL-safe decoding.
 * @return {string} Decoded string.
 */
util.decodeBase64 = function(string, opt_forUrl) {
  if (opt_forUrl) {
    string = string.replace(/-/g, '+').replace(/_/g, '/') +
        ('===').slice(0, string.length % 4);
  }

  return (new Buffer(string, 'base64')).toString();
};


/**
 * Converts object to x-www-form-urlencoded.
 *
 * @param {!Object} object Object to encode.
 * @param {string=} opt_separator Separator for name/value pairs.
 * @return {string} Encoded string.
 */
util.encodeFormData = function(object, opt_separator) {
  return util.__splitUrlData(object).join(opt_separator || '&');
};


/**
 * Converts string in x-www-form-urlencoded to object.
 *
 * @param {string} formData String in x-www-form-urlencoded.
 * @param {string=} opt_separator Separator for name/value pairs.
 * @return {!Object} Decoded object.
 */
util.decodeFormData = function(formData, opt_separator) {
  var result = new util.obj.SafeObject({});

  var values = formData.split(opt_separator || '&');
  var i = 0,
      l = values.length;

  while (i < l) {
    var ind = values[i].indexOf('=');
    var key = values[i].substr(0, ind);
    var value = values[i].substr(ind + 1, values[i].length);

    if (value !== '') {
      result.setByPath(util.unescape(value),
          util.__parseFormDataToken(key));
    }

    i++;
  }

  return result.getCore();
};


/**
 * Encodes special characters in url.
 *
 * @param {string} url URL-string.
 * @return {string} Encoded string.
 */
util.escape = function(url) {
  return encodeURIComponent(url);
};


/**
 * Decodes special characters in url.
 *
 * @param {string} url URL-string.
 * @return {string} Decoded string.
 */
util.unescape = function(url) {
  try {
    return decodeURIComponent(url);
  } catch (error) {
    console.warn('Malformed url: "' + url + '". [util.unescape]');
  }

  return '';
};


/**
 * @param {string} token Element of path in x-www-form-urlencoded string form.
 * @return {!Array.<string>} Generated path.
 */
util.__parseFormDataToken = function(token) {
  if (token.charAt(token.length - 1) !== ']') {
    return [token];
  }

  var nameLength = token.indexOf('[');
  return [token.substring(0, nameLength)].concat(
      token.substring(nameLength + 1, token.length - 1).split(']['));
};


/**
 * @param {!Object} object Object to encode.
 * @param {!Array.<string>=} opt_path The path to elementary unit of path.
 * @return {Array} Array of elementary data containing on object.
 */
util.__splitUrlData = function(object, opt_path) {
  var result = [];

  if (opt_path === undefined) {
    opt_path = [];
  }

  if (typeof object === 'object') {
    for (var key in object) {
      var newPath = opt_path.length === 0 ?
          [key] : (opt_path.join(',') + ',' + key).split(',');

      result = result.concat(util.__splitUrlData(object[key], newPath));
    }
  } else {
    result = [
      opt_path.shift() +
          (opt_path.length > 0 ? '[' + opt_path.join('][') + ']=' : '=') +
          util.escape(String(object))
    ];
  }

  return result;
};


/**
 * Removes whitespace from both sides of a string.
 *
 * @param {string} string String.
 * @return {string} Trimmed string.
 */
util.trim = function(string) {
  try {
    return string.trim();
  } catch (e) {
    return string.replace(/^\s+|\s+$/g, '');
  }
};


/**
 * @param {!Object} data Data.
 * @param {string} key Data key.
 * @return {string} String.
 */
util.extractString = function(data, key) {
  if (typeof data[key] === 'string') {
    return data[key];
  }

  return '';
};


/**
 * @param {!Object} data Data.
 * @param {string} key Data key.
 * @return {number} String.
 */
util.extractNumber = function(data, key) {
  if (typeof data[key] === 'number') {
    return data[key];
  }

  return 0;
};


/**
 * @param {!Object} data Data.
 * @param {string} key Data key.
 * @return {boolean} String.
 */
util.extractBoolean = function(data, key) {
  if (typeof data[key] === 'boolean') {
    return data[key];
  }

  return false;
};


/**
 * @param {!Object} data Data.
 * @param {string} key Data key.
 * @return {!Object} String.
 */
util.extractObject = function(data, key) {
  if (data[key] instanceof Object) {
    return data[key];
  }

  return {};
};


/**
 * Binds a function to a certain context.
 *
 * @param {!Function} fn Function to bind.
 * @param {Object} context Context.
 * @return {!Function} Binded function.
 */
util.fn.bind = function(fn, context) {
  return function() {
    return fn.apply(context, arguments);
  };
};


/**
 * Creates a key-value table.
 *
 * @param {!Array.<string>} keys Keys for a table.
 * @param {!Array} values Values for a table.
 * @return {!Object} Table.
 */
util.obj.glue = function(keys, values) {
  var result = {};
  var i = 0,
      l = keys.length;

  while (i < l) {
    result[keys[i]] = values[i];
    i += 1;
  }

  return result;
};


/**
 * Creates an safe object
 *
 * @param {Object} obj Object.
 * @return {!util.obj.SafeObject} Safe object.
 */
util.obj.safe = function(obj) {
  return new util.obj.SafeObject(obj || {});
};


/**
 * Clones an object
 *
 * @param {!Object} value Value to clone.
 * @return {!Object} Copy of an object.
 */
util.obj.clone = function(value) {
  var clone = new value.constructor();

  for (var param in value) {
    clone[param] = util.clone(value[param]);
  }

  return clone;
};


/**
 * Merges two objects.
 *
 * @param {!Object} base Base object to merge.
 * @param {!Object} target Object to merge with base object.
 * @return {!Object} Result of merging.
 */
util.obj.merge = function(base, target) {
  for (var key in target) {
    if (base[key] instanceof Object &&
        target[key] instanceof Object) {

      base[key] = util.obj.merge(base[key], target[key]);
    } else {
      base[key] = target[key];
    }
  }

  return base;
};


/**
 * Compares two objects
 *
 * @param {!Object} first Object to compare.
 * @param {!Object} second Object to compare.
 * @return {boolean} Result of comparison.
 */
util.obj.equals = function(first, second) {
  for (var param in first) {
    if (!util.equals(first[param], second[param])) {
      return false;
    }
  }

  return true;
};





/**
 * @interface
 */
util.obj.ISafeObject = function() {};


/**
 * Returns data.
 *
 * @param {...(string|number)} var_args Path to value.
 * @return {*} Data.
 */
util.obj.ISafeObject.prototype.get = function(var_args) {};


/**
 * Stores data to a key by its path.
 *
 * @param {*} value Data.
 * @param {...(string|number)} var_args Path to value.
 */
util.obj.ISafeObject.prototype.set = function(value, var_args) {};


/**
 * Returns data stored at key with certain path.
 *
 * @param {!Array.<(string|number)>} path Path to value.
 * @return {*} Data.
 */
util.obj.ISafeObject.prototype.getByPath = function(path) {};


/**
 * Stores data to a key with certain path.
 *
 * @param {*} value Data.
 * @param {!Array.<(string|number)>} path Path to value.
 */
util.obj.ISafeObject.prototype.setByPath = function(value, path) {};



/**
 * @constructor
 * @implements {util.obj.ISafeObject}
 * @param {!Object} data Source data.
 */
util.obj.SafeObject = function(data) {

  /**
   * @type {!Object}
   */
  this.__core = data;
};


/**
 * Returns source data.
 *
 * @return {!Object} Source data.
 */
util.obj.SafeObject.prototype.getCore = function() {
  return this.__core;
};


/**
 * @param {...(string|number)} var_args Path to value.
 * @return {*} Data.
 */
util.obj.SafeObject.prototype.get = function(var_args) {
  return this.getByPath(Array.prototype.slice.call(arguments));
};


/**
 * @param {*} value Data.
 * @param {...(string|number)} var_args Path to value.
 */
util.obj.SafeObject.prototype.set = function(value, var_args) {
  var path = Array.prototype.slice.call(arguments);
  this.setByPath(path.shift(), path);
};


/**
 * @inheritDoc
 */
util.obj.SafeObject.prototype.getByPath = function(path) {
  var result = this.__core;

  var i = 0,
      l = path.length;

  while (i < l) {
    if (result === null || path[i] === '') {
      break;
    }

    var value = result[path[i]];
    if (value !== undefined) {
      result = value;
    } else {
      result = null;
    }

    i += 1;
  }

  return result;
};


/**
 * @inheritDoc
 */
util.obj.SafeObject.prototype.setByPath = function(value, path) {
  var scope = this.__core;

  var i = 0,
      l = path.length;

  while (i < l) {
    var key = path[i];

    if (key === '') {
      key = 0;

      while (scope[key] !== undefined) {
        key += 1;
      }
    }

    i += 1;

    if (i === l) {
      scope[key] = value;
    } else if (scope[key] === undefined) {
      scope[key] = isNaN(path[i]) ? {} : [];
    }

    scope = scope[key];
  }
};


/**
 * @param {...string} var_args
 * @return {string}
 */
util.obj.SafeObject.prototype.getString = function(var_args) {
  var value = this.getByPath(Array.prototype.slice.call(arguments));

  if (typeof value === 'string') {
    return value;
  }

  return '';
};


/**
 * @param {...string} var_args
 * @return {number}
 */
util.obj.SafeObject.prototype.getNumber = function(var_args) {
  var value = this.getByPath(Array.prototype.slice.call(arguments));

  if (typeof value === 'number') {
    return value;
  }

  return 0;
};


/**
 * @param {...string} var_args
 * @return {boolean}
 */
util.obj.SafeObject.prototype.getBoolean = function(var_args) {
  var value = this.getByPath(Array.prototype.slice.call(arguments));

  if (typeof value === 'boolean') {
    return value;
  }

  return false;
};


/**
 * @param {...string} var_args
 * @return {!Object}
 */
util.obj.SafeObject.prototype.getObject = function(var_args) {
  var value = this.getByPath(Array.prototype.slice.call(arguments));

  if (value instanceof Object) {
    return value;
  }

  return {};
};



/**
 * @interface
 */
util.obj.ICache = function() {};


/**
 * @param {string} key Ключ хранения.
 * @return {*} Сушность.
 */
util.obj.ICache.prototype.pull = function(key) {};


/**
 * @param {string} key Ключ хранения.
 * @param {*} entity Cущность.
 */
util.obj.ICache.prototype.stash = function(key, entity) {};



/**
 * @constructor
 * @implements {util.obj.ICache}
 */
util.obj.Cache = function() {

  /**
   * @type {!Object}
   */
  this.__cache = {};
};


/**
 * @override
 */
util.obj.Cache.prototype.pull = function(key) {
  return this.__cache[key] || null;
};


/**
 * @override
 */
util.obj.Cache.prototype.stash = function(key, entity) {
  if (this.__cache[key] === undefined) {
    this.__cache[key] = entity;
  } else {
    console.warn('Duplicate ' + entity + ' stash for key "' + key + '".');
  }
};


/**
 * Очищение кеша.
 */
util.obj.Cache.prototype.flush = function() {
  this.__cache = {};
};


/**
 * JS Implementation of MurmurHash2
 *
 * @see http://github.com/garycourt/murmurhash-js
 * @see http://sites.google.com/site/murmurhash/
 *
 * @param {string} str ASCII only.
 * @param {number} seed Random seed.
 * @return {number} 32-bit positive integer hash.
 */
util.hash.murmur = function(str, seed) {
  var l = str.length;
  var h = seed ^ l;
  var i = 0;
  var k = 0;

  while (l >= 4) {
    k = ((str.charCodeAt(i) & 0xff)) |
        ((str.charCodeAt(i + 1) & 0xff) << 8) |
        ((str.charCodeAt(i + 2) & 0xff) << 16) |
        ((str.charCodeAt(i + 3) & 0xff) << 24);

    k = (((k & 0xffff) * 0x5bd1e995) +
        ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));

    k ^= k >>> 24;
    k = (((k & 0xffff) * 0x5bd1e995) +
        ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));

    h = (((h & 0xffff) * 0x5bd1e995) +
        ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^ k;

    l -= 4;
    i += 4;
  }

  switch (l) {
    case 3: h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
    case 2: h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
    case 1: {
      h ^= (str.charCodeAt(i) & 0xff);
      h = (((h & 0xffff) * 0x5bd1e995) +
          ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));
    }
  }

  h ^= h >>> 13;
  h = (((h & 0xffff) * 0x5bd1e995) +
      ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));
  h ^= h >>> 15;

  return h >>> 0;
};



/**
 *
 *
 * @interface
 */
util.uid.IIdGenerator = function() {};


/**
 * Generates id.
 *
 * @return {string} Generated identificator.
 */
util.uid.IIdGenerator.prototype.generateId = function() {};



/**
 *
 *
 * @constructor
 * @implements {util.uid.IIdGenerator}
 * @param {string} prefix Prefix for identifier.
 * @param {boolean=} opt_isIncremental Flag whether to use an increment or not.
 */
util.uid.PrefixIdGenerator = function(prefix, opt_isIncremental) {

  /**
   * @type {string}
   */
  this.__prefix = prefix;

  /**
   * @type {number}
   */
  this.__counter = 0;

  /**
   * @type {boolean}
   */
  this.__isIncremental =
      opt_isIncremental === undefined ? true : opt_isIncremental;
};


/**
 * Generates identifier.
 *
 * @inheritDoc
 */
util.uid.PrefixIdGenerator.prototype.generateId = function() {
  var result = this.__prefix + (this.__counter += 1).toString(36);

  if (this.__isIncremental) {
    return result;
  }

  return result + Math.random().toString(36).substr(2);
};


/**
 * Returns identifier's prefix.
 *
 * @return {string} Prefix of identifier.
 */
util.uid.PrefixIdGenerator.prototype.getPrefix = function() {
  return this.__prefix;
};


/**
 * Search the index of an element in array.
 *
 * @param {*} element element to find.
 * @param {!Array} array Array containing an element.
 * @return {number} Index of element.
 */
util.arr.indexOf = function(element, array) {
  if (array.indexOf !== undefined) {
    return array.indexOf(element);
  } else {
    var i = 0,
        l = array.length;
    while (i < l) {
      if (array[i] === element) {
        return i;
      }
      i++;
    }
  }
  return -1;
};


/**
 * Creates array of unique strings..
 *
 * @param {!Array.<string>} set Array of strings.
 * @return {!Array.<string>} Array of unique strings.
 */
util.arr.unique = function(set) {
  var result = {};
  for (var i = 0, l = set.length; i < l; i += 1) {
    result[set[i]] = true;
  }

  return Object.keys(result) || [];
};


/**
 * Fills array with data.
 *
 * @param {!Array.<*>} array Array to fill.
 * @param {*} value Data.
 * @return {!Array.<*>} Filled array.
 */
util.arr.fill = function(array, value) {
  var i = 0,
      l = array.length;

  while (i < l) {
    array[i] = value;

    i += 1;
  }

  return array;
};


/**
 * Creates an array.
 *
 * @param {number} length Size of array.
 * @param {*=} opt_defaultValue Default value to set for each element of array.
 * @return {!Array.<*>} Array.
 */
util.arr.create = function(length, opt_defaultValue) {
  return util.fill(new Array(length),
      opt_defaultValue !== undefined ? opt_defaultValue : null);
};


/**
 * Clones an array
 *
 * @param {!Array} array Array o clone.
 * @return {!Array} Copy of the array.
 */
util.arr.clone = function(array) {
  return array.slice(0);
};


/**
 * Converts object to array.
 *
 * @param {{length: number}} list Object resembles an array.
 * @return {!Array} Array.
 */
util.arr.cast = function(list) {
  if (list instanceof Object) {
    return Array.prototype.slice.call(list);
  }

  return [];
};


/**
 * Converts each element of an array to string.
 *
 * @param {{length: number}} list Object resembles an array.
 * @return {!Array.<string>} array of strings.
 */
util.arr.castString = function(list) {
  var i = 0,
      l = list.length;

  var result = new Array(l);
  while (i < l) {
    if (typeof list[i] === 'string') {
      result[i] = list[i];
    } else {
      result[i] = String(list[i]);
    }

    i += 1;
  }

  return result;
};


/**
 * Converts each element of an array to object
 *
 * @param {{length: number}} list Object resembles an array.
 * @return {!Array.<!Object>} Array of objects.
 */
util.arr.castObject = function(list) {
  var i = 0,
      l = list.length;

  var result = new Array(l);
  while (i < l) {
    if (list[i] instanceof Object) {
      result[i] = list[i];
    } else {
      result[i] = Object(list[i]);
    }

    i += 1;
  }

  return result;
};


/**
 * @type {!Object.<string, !Array.<string>>}
 */
util.cli.__map = {};


/**
 * @type {!Object.<string, *>}
 */
util.cli.__defaults = {};


/**
 * @type {boolean}
 */
util.cli.__isParsed = false;


/**
 * @param {string} name Имя переменной.
 * @return {!Array} Значение.
 */
util.cli.getArray = function(name) {
  if (!util.cli.__isParsed) {
    util.cli.__extractValues();
  }

  if (util.cli.__map[name] !== undefined) {
    return util.cli.__map[name].slice(0);
  }

  if (util.cli.__defaults[name] !== undefined) {
    return [].concat(util.cli.__defaults[name]);
  }

  return [];
};


/**
 * @param {string} name Имя переменной.
 * @return {string} Значение.
 */
util.cli.getString = function(name) {
  if (!util.cli.__isParsed) {
    util.cli.__extractValues();
  }

  if (util.cli.__map[name] !== undefined &&
      util.cli.__map[name][0] !== undefined) {

    return util.cli.__map[name][0];
  }

  if (util.cli.__defaults[name] !== undefined) {
    return String(util.cli.__defaults[name]);
  }

  return '';
};


/**
 * @param {string} name Имя переменной.
 * @return {number} Значение.
 */
util.cli.getNumber = function(name) {
  if (!util.cli.__isParsed) {
    util.cli.__extractValues();
  }

  if (util.cli.__map[name] !== undefined &&
      util.cli.__map[name][0] !== undefined) {

    return Number(util.cli.__map[name][0]);
  }

  if (util.cli.__defaults[name] !== undefined) {
    return Number(util.cli.__defaults[name]);
  }

  return 0;
};


/**
 * @param {string} name Имя переменной.
 * @return {boolean} Значение.
 */
util.cli.getBoolean = function(name) {
  if (!util.cli.__isParsed) {
    util.cli.__extractValues();
  }

  if (util.cli.__map[name] === undefined) {
    return Boolean(util.cli.__defaults[name]);
  }

  return util.cli.__map[name].length > 0 &&
      util.cli.__map[name][0].toLowerCase() !== 'false' &&
          Boolean(util.cli.__map[name][0]);
};


/**
 *
 */
util.cli.__extractValues = function() {
  var agrv = process.argv;
  var args = [];

  util.cli.__map = {};

  for (var i = 0, l = agrv.length; i < l; i += 1) {
    args = args.concat(agrv[i].split('='));
  }

  var currentArg = '';
  while (args.length > 0) {
    currentArg = util.cli.__applyArgument(args.shift(), currentArg);
  }

  util.cli.__isParsed = true;
};


/**
 * @param {string} arg Аргумент.
 * @param {string} currentArg Аргумент.
 * @return {string} Аргумент.
 */
util.cli.__applyArgument = function(arg, currentArg) {
  var value = '';
  var newArg = '';

  if (arg.indexOf('--') === 0) {
    newArg = arg.substr(2);
  } else {
    value = arg;
  }

  if (currentArg !== '') {
    if (!util.cli.__map[currentArg]) {
      util.cli.__map[currentArg] = [];
    }

    util.cli.__map[currentArg].push(value);
    currentArg = '';
  }

  if (newArg !== '') {
    currentArg = newArg;
  }

  return currentArg;
};


/**
 * @type {!util.obj.SafeObject}
 */
util.config.__safeCore = new util.obj.SafeObject({});


/**
 * @type {!Object}
 */
util.config.__core = {};


/**
 * @param {string} filename Путь к файлу с конфигом.
 */
util.config.load = function(filename) {
  try {
    var config = require(filename);
    util.config.__core = util.obj.merge(util.config.__core, config);
  } catch (error) {
    console.error('Unable to open config from file "' + filename + '".');
  }

  util.config.__safeCore = new util.obj.SafeObject(util.config.__core);
};


/**
 * @param {...(string|number)} var_args Путь к данным.
 * @return {string} Результат.
 */
util.config.getString = function(var_args) {
  var result = util.config.__safeCore.getByPath(util.arr.cast(arguments));
  if (result !== null) {
    return String(result);
  }

  return '';
};


/**
 * @param {...(string|number)} var_args Путь к данным.
 * @return {number} Результат.
 */
util.config.getNumber = function(var_args) {
  var result = util.config.__safeCore.getByPath(util.arr.cast(arguments));
  if (result !== null) {
    return Number(result);
  }

  return 0;
};


/**
 * @param {...(string|number)} var_args Путь к данным.
 * @return {boolean} Результат.
 */
util.config.getBoolean = function(var_args) {
  return !!util.config.__safeCore.getByPath(util.arr.cast(arguments));
};


/**
 * @param {...(string|number)} var_args Путь к данным.
 * @return {!Object} Результат.
 */
util.config.getObject = function(var_args) {
  var result = util.config.__safeCore.getByPath(util.arr.cast(arguments));
  if (result instanceof Object) {
    return result;
  }

  return {};
};


/**
 * @param {...(string|number)} var_args Путь к данным.
 * @return {!Array.<string>} Результат.
 */
util.config.getObjectKeys = function(var_args) {
  var obj = util.config.__safeCore.getByPath(util.arr.cast(arguments));
  var result = [];

  for (var key in obj) {
    result.push(key);
  }

  return result;
};


/**
 * @param {...(string|number)} var_args Путь к данным.
 * @return {!Array} Результат.
 */
util.config.getArray = function(var_args) {
  var result = util.config.__safeCore.getByPath(util.arr.cast(arguments));
  if (result instanceof Array) {
    return result;
  }

  return [];
};


/**
 * @typedef {?function(!Object=):string}
 */
util.log.AdditionalLog;


/**
 * @param {number=} opt_level
 * @param {!util.log.AdditionalLog=} opt_additionalLog .
 */
util.log.init = function(opt_level, opt_additionalLog) {
  console.__log = console.log;

  if (opt_level !== undefined) {
    util.log.__level = opt_level;
  }

  if (opt_additionalLog) {
    util.log.__additionalLog = opt_additionalLog;
  }

  console.log = util.log.__log;
  console.info = util.log.__info;
  console.warn = util.log.__warn;
  console.error = util.log.__error;
};


/**
 * @param {util.log.Color} color
 * @param {!Array} args
 * @return {!Array}
 */
util.log.__args = function(color, args) {
  return [color].concat(args).concat(util.log.Color.__RESET);
};


/**
 * @return {string} Timestamp string.
 */
util.log.__timestamp = function() {
  var date = new Date();
  var ms = String(date.getMilliseconds());
  while (ms.length < 3) {
    ms = '0' + ms;
  }

  return String(date).split(' ').slice(1, 5).join(' ') + '.' + ms + ' ';
};


/**
 * @param {!Arguments} args
 * @return {string}
 */
util.log.__filterText = function(args) {
  return args[0] || '';
};


/**
 * @param {!Arguments} args
 * @return {!Object|undefined}
 */
util.log.__filterOrd = function(args) {
  return args[1] instanceof Object ? args[1] : undefined;
};


/**
 * @param {...} var_args
 */
util.log.__log = function(var_args) {
  if (util.log.__level > 3) {
    var message = util.log.__filterText(arguments);
    var ord = util.log.__filterOrd(arguments);
    var text = util.log.__timestamp() + message;
    var additionalInfo = util.log.__additionalLog();
    console.__log.apply(console, [text, ord || '', additionalInfo]);
  }
};


/**
 * @param {...} var_args
 */
util.log.__info = function(var_args) {
  if (util.log.__level > 2) {
    var message = util.log.__filterText(arguments);
    var ord = util.log.__filterOrd(arguments);
    var fn = new Error().stack.split('\n').slice(2)[0] || '';
    var text = util.log.Prefix.INFO + ' ' + util.log.__timestamp() + ' ' +
        fn.substring(7, fn.indexOf('(') - 1) + ' ' + message;

    var additionalInfo = util.log.__additionalLog();

    console.__log.apply(console,
        util.log.__args(util.log.Color.LIGHT_GRAY, [text, ord || '',
          additionalInfo]));
  }
};


/**
 * @param {...} var_args
 */
util.log.__warn = function(var_args) {
  if (util.log.__level > 1) {
    var message = util.log.__filterText(arguments);
    var ord = util.log.__filterOrd(arguments);
    var fn = new Error().stack.split('\n').slice(2)[0] || '';
    var text = util.log.Prefix.WARN + ' ' + util.log.__timestamp() + ' ' +
        fn.substring(7, fn.indexOf('(') - 1) + ' ' + message;

    var additionalInfo = util.log.__additionalLog();

    console.__log.apply(console,
        util.log.__args(
            util.log.Color.YELLOW, [text, ord || '', additionalInfo]));
  }
};


/**
 * @param {...} var_args
 */
util.log.__error = function(var_args) {
  if (util.log.__level > 0) {
    var message = util.log.__filterText(arguments);
    var ord = util.log.__filterOrd(arguments);
    var fn = new Error().stack.split('\n').slice(2)[0] || '';
    var stackLines = new Error().stack.split('\n');

    if (stackLines.length >= 2) {
      stackLines = stackLines.slice(2);
    }
    var stackText = util.log.Prefix.ERROR_STACK + ' | ' +
        stackLines.join('\n' + util.log.Prefix.ERROR_STACK + ' | ');
    var text = util.log.Prefix.ERROR + ' ' + util.log.__timestamp() + ' ' +
        fn.substring(7, fn.indexOf('(') - 1) + ' ' + message + '\n' + stackText;

    var additionalInfo = util.log.__additionalLog();

    console.__log.apply(console,
        util.log.__args(
            util.log.Color.RED, [text, ord || '', additionalInfo]));
  }
};


/**
 * @type {number}
 */
util.log.__level = 3;


/**
 * @param {!Object=} opt_ord
 * @return {string}
 */
util.log.__additionalLog = function(opt_ord) {
  return '';
};


/**
 * @enum {string}
 */
util.log.Prefix = {
  INFO: '[INFO]',
  WARN: '[WARNING]',
  ERROR: '[ERROR]',
  ERROR_STACK: 'ERROR STACK'
};


/**
 * @enum {string}
 */
util.log.Color = {
  GREEN: '\033[32m',
  YELLOW: '\033[33m',
  RED: '\033[31m',
  MAGENTA: '\033[35m',
  LIGHT_GRAY: '\033[1;30m',
  __RESET: '\033[0m'
};


/**
 * Encodes object to JSON.
 *
 * @param {*} object The object to code.
 * @return {string} JSON string.
 */
util.io.encodeJson = function(object) {
  try {
    return JSON.stringify(object) || '';
  } catch (error) {
    console.warn('JSON encoding error: "' + error.message + '".', object);
  }

  return '';
};


/**
 * Converts JSON to object.
 *
 * @param {string} data JSON string..
 * @return {*} JSON object.
 */
util.io.decodeJson = function(data) {
  try {
    return JSON.parse(data);
  } catch (error) {
    console.warn('JSON parsing error: "' + error.message + '".', data);
  }

  return null;
};


/**
 * Encodes string to base64 format.
 *
 * @param {string} string Строка.
 * @param {boolean=} opt_forUrl Флаг URL-безопасного кодирования.
 * @return {string} Закодированная строка.
 */
util.io.encodeBase64 = function(string, opt_forUrl) {
  var result = (new Buffer(string)).toString('base64');

  if (opt_forUrl) {
    result = result.replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/\=+\s*$/g, '');
  }

  return result;
};


/**
 * Converts base64 to ordinary string.
 *
 * @param {string} string Base64 string.
 * @param {boolean=} opt_forUrl Flag for URL-safe decoding.
 * @return {string} Decoded string.
 */
util.io.decodeBase64 = function(string, opt_forUrl) {
  if (opt_forUrl) {
    string = string.replace(/-/g, '+').replace(/_/g, '/') +
        ('===').slice(0, string.length % 4);
  }

  return (new Buffer(string, 'base64')).toString();
};


/**
 * Converts object to x-www-form-urlencoded.
 *
 * @param {!Object} object Object to encode.
 * @param {string=} opt_separator Separator for name/value pairs.
 * @return {string} Encoded string.
 */
util.io.encodeFormData = function(object, opt_separator) {
  return util.io.__splitUrlData(object).join(opt_separator || '&');
};


/**
 * Converts string in x-www-form-urlencoded to object.
 *
 * @param {string} formData String in x-www-form-urlencoded.
 * @param {string=} opt_separator Separator for name/value pairs.
 * @return {!Object} Decoded object.
 */
util.io.decodeFormData = function(formData, opt_separator) {
  var result = new util.obj.SafeObject({});

  var values = formData.split(opt_separator || '&');
  var i = 0,
      l = values.length;

  while (i < l) {
    var ind = values[i].indexOf('=');
    var key = values[i].substr(0, ind);
    var value = values[i].substr(ind + 1, values[i].length);

    if (value !== '') {
      result.setByPath(util.io.unescape(value),
          util.io.__parseFormDataToken(key));
    }

    i++;
  }

  return result.getCore();
};


/**
 * Encodes special characters in url.
 *
 * @param {string} url URL-string.
 * @return {string} Encoded string.
 */
util.io.escape = function(url) {
  return encodeURIComponent(url);
};


/**
 * Decodes special characters in url.
 *
 * @param {string} url URL-string.
 * @return {string} Decoded string.
 */
util.io.unescape = function(url) {
  try {
    return decodeURIComponent(url);
  } catch (error) {
    console.warn('Malformed url: "' + url + '".');
  }

  return '';
};


/**
 * @param {string} token Element of path in x-www-form-urlencoded string form.
 * @return {!Array.<string>} Generated path.
 */
util.io.__parseFormDataToken = function(token) {
  if (token.charAt(token.length - 1) !== ']') {
    return [token];
  }

  var nameLength = token.indexOf('[');
  return [token.substring(0, nameLength)].concat(
      token.substring(nameLength + 1, token.length - 1).split(']['));
};


/**
 * @param {!Object} object Object to encode.
 * @param {!Array.<string>=} opt_path The path to elementary unit of path.
 * @return {Array} Array of elementary data containing on object.
 */
util.io.__splitUrlData = function(object, opt_path) {
  var result = [];

  if (opt_path === undefined) {
    opt_path = [];
  }

  if (typeof object === 'object') {
    for (var key in object) {
      var newPath = opt_path.length === 0 ?
          [key] : (opt_path.join(',') + ',' + key).split(',');

      result = result.concat(util.io.__splitUrlData(object[key], newPath));
    }
  } else {
    result = [
      opt_path.shift() +
          (opt_path.length > 0 ? '[' + opt_path.join('][') + ']=' : '=') +
          util.io.escape(String(object))
    ];
  }

  return result;
};


/**
 * Основная область имен библотеки.
 *
 * Библиотека предназначена для организации алгоритмов асинхронной обработки
 * данных.
 *
 * Основным понятиями асинхронного алгоритма являются шаг и сценарий, состоящий
 * из множества шагов. В свою очередь шаг является сценарием состоящим из
 * соответсвующего шага.
 *
 * @namespace
 */
var async = {};


/**
 * @namespace
 */
async.assert = {};


/**
 * @namespace
 */
async.console = {};


/**
 * Область имен объединяющая функции для работы с входными данными сценария.
 *
 * @namespace
 */
async.input = {};


/**
 * @namespace
 */
async.input.cursor = {};


/**
 * @namespace
 */
async.input.cursor.cache = {};


/**
 * @namespace
 */
async.input.cursor.filter = {};


/**
 * Область имен объединяющая функции для работы с результатом выполнения.
 *
 * @namespace
 */
async.output = {};


/**
 * Область имен объединяющая функции для создания сценариев обработки
 * входных данных.
 *
 * @namespace
 */
async.proc = {};


/**
 * Область имен объединяющая функции для создания сценариев обработки
 * входных наборов данных.
 *
 * @namespace
 */
async.proc.fold = {};


/**
 * Область имен объединяющая функции для создания сценариев обработки
 * входных наборов данных соответсвующим набором шагов.
 *
 * @namespace
 */
async.proc.zip = {};


/**
 * @namespace
 */
async.index = {};


/**
 * Все, что может выступать в качетсве контекста шага.
 *
 * @see async.Step
 * @see async.Step#call
 *
 * @typedef {*}
 */
async.Context;


/**
 * Все, что может выступать в качетсве входных данных шага.
 *
 * @see async.Step
 * @see async.Step#call
 *
 * @typedef {*}
 */
async.Input;


/**
 * Все, что может выступать в качетсве результата выполнения шага.
 *
 * @see async.CompleteHandler
 *
 * @see async.Step
 * @see async.CompleteHandler
 *
 * @typedef {*}
 */
async.Output;


/**
 * Обработчик результата выполнения шага.
 *
 * Обработчиком является функция принимающая в качетве аргумента результат
 * выполнения шага.
 *
 * @see async.Step
 * @see async.Step#call
 * @see async.Output
 *
 * @typedef {?function(async.Output)}
 */
async.CompleteHandler;


/**
 * Все, что может выступать в качетсве ошибки выполнения шага.
 *
 * @see async.ErrorHandler
 *
 * @typedef {*}
 */
async.Error;


/**
 * Обработчик ошибки выполнения шага.
 *
 * Обработчиком является функция принимающая в качетве аргументов оюъект ошибки
 * и ее код. Код ошибки является необязательным параметром.
 *
 * @see async.Step
 * @see async.Step#call
 * @see async.Error
 *
 * @typedef {?function(async.Error, number=)}
 */
async.ErrorHandler;


/**
 * Шаг сценария.
 *
 * @see async.IStep
 * @see async.Scenario
 *
 * @typedef {async.IStep|?function(async.Input, !async.CompleteHandler,
 *    !async.ErrorHandler)}
 */
async.Step;


/**
 * Сценарий выполенения.
 *
 * Сценарием является шаг, в рамках выполнения которого по определенному правилу
 * связывается выполнение множества шагов с помощью соответсвующих обработчиков
 * результата либо ошибки. Запуск выполнения шагов сценария определяется
 * соответсвующим правилом.
 *
 * Для большинства сценариев вызов обработчика ошибки одного из шагов, влечет
 * за собой вызов обработчика ошибки сценария и прекращению дальнейшего
 * выполнения шагов.
 *
 * @see async.try
 * @see async.Step
 * @see async.ErrorHandler
 * @see async.Sequence
 * @see async.Parallel
 *
 * @typedef {async.Step}
 */
async.Scenario;


/**
 * Сценарий последовательного выполнения.
 *
 * Сценарий последовательного выполнения определяется множеством шагов,
 * выполнение которых будет вызвано последовательно в асинхронном смысле.
 *
 * Последовательно в асинхронном смысле означает то, что выполнение шагов
 * сценария не пересекается во времени.
 *
 * Для последовательного выполнения актуально наличие условия продолжнения,
 * условия, невыполнение которого ведет к прерыванию поледовательности
 * выполнения.
 *
 * @see async.Step
 * @see async.Scenario
 * @see async.ConditionStep
 *
 * @typedef {async.Scenario}
 */
async.Sequence;


/**
 * Сценарий параллельного выполнения.
 *
 * Паралельность в асинхронном смысле означает то, выполнение всех шагов
 * сценария может пересечься во времени.
 *
 * @see async.Step
 * @see async.Scenario
 *
 * @typedef {async.Scenario}
 */
async.Parallel;


/**
 * Шаг проверки условия.
 *
 * Результатом шага проверки должно являтся булево значение результата
 * проверки.
 *
 * @see async.Input
 * @see async.Step
 * @see async.Sequence
 *
 * @typedef {async.Step}
 */
async.ConditionStep;


/**
 * @typedef {?function(...):!async.Step}
 */
async.StepRouter;


/**
 * Создатель шага обработки ошибки, который будет вызван при появении первой
 * ошибки целевого шага.
 *
 * Созданный обработчик вызовется в качетсве "замены" целевого шага с
 * соответсвующими входными данными и контекстом.
 *
 * Собственные ошибки обработчика не будут отловлены и повлияют на выполнение
 * сценария, в рамках котрого была выполнена попытка отловить ошибки целевого
 * шага.
 *
 * @see async.try
 * @see async.IStep
 * @see async.Input
 * @see async.Context
 *
 * @typedef {?function(async.Error, number=):!async.Step}
 */
async.FailCatcher;


/**
 * Создатель обработчика ошибки не влияющего на ход выполнения сценария.
 *
 * Созданный обработчик вызывается при появлении любой ошибки при
 * выполнении целевого шага.
 *
 * Обработчик ошибки будет вызвваться в контексте сценария.
 *
 * @see async.FailCatcher
 * @see async.IStep
 *
 * @typedef {?function():!async.ErrorHandler}
 */
async.TolerantCatcher;


/**
 * Создание пустого обработчика ошибки.
 *
 * @return {!async.ErrorHandler} Обработчик ошибки.
 */
async.NOP_CATCHER = function() {
  return function() {};
};


/**
 * Шаг проверки, всегда возвращающий положительный результат.
 *
 * @see async.ConditionStep
 *
 * @param {async.Input} input Входные данные.
 * @param {!async.CompleteHandler} complete Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.IS_INPUT = function(input, complete, cancel) {
  complete(true);
};


/**
 * Шаг проверки, того входные данные не `null`.
 *
 * @see async.ConditionStep
 *
 * @param {async.Input} input Входные данные.
 * @param {!async.CompleteHandler} complete Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.IS_NOT_NULL = function(input, complete, cancel) {
  complete(input !== null);
};


/**
 * Шаг проверки, того входные данные равны `null`.
 *
 * @see async.ConditionStep
 *
 * @param {async.Input} input Входные данные.
 * @param {!async.CompleteHandler} complete Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.IS_NULL = function(input, complete, cancel) {
  complete(input === null);
};


/**
 * Шаг немедленно возращающий переданное ему значение без изменений.
 *
 * @param {async.Input} input Входные данные.
 * @param {!async.CompleteHandler} complete Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.nop = function(input, complete, cancel) {
  complete(input);
};


/**
 * Создание шага передающего указанные входные данные в обработчик результата.
 *
 * @see async.Input
 * @see async.Output
 *
 * @param {async.Input} input Входные данные.
 * @return {!async.Step} Созданный шаг.
 */
async.insert = function(input) {

  /**
   * @param {async.Input} _ Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function insert(_, complete, cancel) {
    complete(input);
  }

  return insert;
};


/**
 * @param {!async.Step} step Шаг требующий соответсвующие входные данные.
 * @param {!async.Step=} opt_target Шаг получения входных данных.
 * @return {!async.Step} Созданный шаг.
 */
async.use = function(step, opt_target) {
  if (opt_target === undefined) {
    return step;
  }

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function use(input, complete, cancel) {
    var context = this;

    function passComplete() {
      complete(input);
    }

    /**
     * @param {async.Output} output
     */
    function handleOutput(output) {
      step.call(context, output, passComplete, cancel);
    }

    opt_target.call(this, input, handleOutput, cancel);
  }

  return use;
};


/**
 * Приведения "полушага" к шагу.
 *
 * Полушагом является функция в качестве аргументов принимающая обработчик
 * результата и обработчик ошибки соотвствующего вида после всех обязательных
 * параметров и до опциональных. Например:
 *
 * ```
 * function semiActor(a, b, c, <b>complete</b>, <b>cancel</b>, opt_d, opt_b) {
 *   // ...
 * }
 * ```
 *
 * Таким образом, полушаг является функцией, обязательные и опциональные
 * аргументы которого разделены функциями обработки результата и ошибки.
 *
 * Приведение осуществляется за счет выполнения шагов источников значений
 * аргументов и передачи их результата в вызов полушага. Входными данными для
 * каждого источника являются данные вызова созданного шага.
 *
 * Так, например, для передачи входных данных шага в каждый из обязательных
 * аргументов полушага приведение и вызов будет выглядеть следующим образом:
 *
 * ```
 * var actor = async.cast(semiActor, [async.nop, async.nop, async.nop]);
 * actor.call(null, 1, console.log, console.error);
 * ```
 *
 * Так как шаг `async.nop` передает входные данные в обработчик результата, в
 * аргументы `a`, `b` и `c` будет передано входное значение `1`.
 *
 * @see async.CompleteHandler
 * @see async.ErrorHandler
 * @see async.Step
 * @see async.nop
 *
 * @param {function(...)} semiActor Полушаг.
 * @param {!Array.<!async.Step>} sources Массив источников значений
 *    обязательных аргументов соответсвующий их последовательнотии в полушаге.
 * @param {!Array.<!async.Step>=} opt_sources Массив источников значений не
 *    обязательных аргументов соответсвующий их последовательнотии в полушаге.
 * @return {!async.Step} Созданный шаг.
 */
async.cast = function(semiActor, sources, opt_sources) {
  var sourcesLength = sources.length;

  if (opt_sources !== undefined) {
    sources = sources.concat(opt_sources);
  }

  /**
   * @this {async.Context}
   * @param {async.Input} data Данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function cast(data, complete, cancel) {
    var self = this;

    /**
     * @param {!Array.<*>} args
     */
    function apply(args) {
      args.splice(sourcesLength, 0, complete, cancel);
      semiActor.apply(self, args);
    }

    async.proc.parallel(sources,
        async.output.ARRAY_COLLECTOR).call(this, data, apply, cancel);
  }

  return cast;
};


/**
 * Приведения любой функции к шагу.
 *
 * Приведение осуществляется за счет передачи результата выполнения заданной
 * функции в обработчик результата.
 *
 * Передача агрументов в заданную функцию осуществляется при небхожимости
 * тем же способом что и для `async.cast`.
 *
 * @see async.Step
 * @see async.cast
 * @param {function(...)} fn Заданная функция.
 * @param {!Array.<!async.Step>=} opt_sources Массив источников значений
 *    аргументов соответсвующий их последовательнотии в заданной функции.
 * @return {!async.Step} Созданный шаг.
 */
async.wrap = function(fn, opt_sources) {
  var sources = opt_sources || [];

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function wrap(input, complete, cancel) {
    var self = this;

    /**
     * @param {!Array.<*>} args
     */
    function apply(args) {
      var result = fn.apply(self, args);
      if (result !== undefined) {
        complete(result);
      } else {
        complete(null);
      }
    }

    async.proc.parallel(sources,
        async.output.ARRAY_COLLECTOR).call(this, input, apply, cancel);
  }

  return wrap;
};


/**
 * @param {!async.Step} condition Шаг условия.
 * @return {!async.Step} Шаг фильтрации.
 */
async.filter = function(condition) {

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function filter(input, complete, cancel) {

    /**
     * @param {async.Output} output
     */
    function handleCondition(output) {
      complete(output ? input : null);
    }

    condition.call(this, input, handleCondition, cancel);
  }

  return filter;
};


/**
 * Создание сценария последовательной обработки результата предыдущего шага.
 *
 * Перый шаг в качеcтве входных данных получает входные данные созданного
 * сценария.
 *
 * Шаг проверки получает на вход данные каждого шага сценария.
 *
 * @see async.ConditionStep
 * @see async.Sequence
 *
 * @param {!Array.<!async.Step>} steps Набор шагов.
 * @param {!async.ConditionStep=} opt_condition Шаг проверки условия
 *    продолжения последовательности.
 * @return {!async.Sequence} Созданный сценарий.
 */
async.sequence = function(steps, opt_condition) {
  var condition = opt_condition || async.IS_INPUT;

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function sequence(input, complete, cancel) {
    var lastIndex = steps.length - 1;
    var currentIndex = -1;
    var context = this;

    /**
     * @param {async.Error} error Ошибка.
     * @param {number=} opt_code Код ошибки.
     */
    function localCancel(error, opt_code) {
      currentIndex = lastIndex;
      cancel(error, opt_code);
    }


    /**
     * @param {async.Output} output Данные.
     */
    function localComplete(output) {
      condition.call(context, output, function(result) {
        if (currentIndex < lastIndex && result) {
          steps[currentIndex += 1]
              .call(context, output, localComplete, localCancel);
        } else {
          complete(output);
        }
      }, localCancel);
    }

    localComplete(input);
  }

  return sequence;
};


/**
 * Последовательность шагов, выполняемая пока каждый шаг получает на вход
 * значение, отличающееся от `null`.
 *
 * @see async.ConditionStep
 * @see async.Sequence
 * @see async.IS_NOT_NULL
 *
 * @param {!Array.<!async.Step>} steps Набор шагов.
 * @return {!async.Scenario} Созданный сценарий.
 */
async.chain = function(steps) {
  return async.sequence(steps, async.IS_NOT_NULL);
};


/**
 * Последовательность шагов, выполняемая пока каждый шаг получает на вход
 * значение равняющееся `null`.
 *
 * @see async.ConditionStep
 * @see async.Sequence
 * @see async.IS_NULL
 *
 * @param {!Array.<!async.Step>} steps Набор шагов.
 * @return {!async.Scenario} Созданный сценарий.
 */
async.fallback = function(steps) {
  return async.sequence(steps, async.IS_NULL);
};


/**
 * @param {!async.StepRouter} router
 * @param {!(Array.<!async.Step>|async.Step)=} opt_decoder
 * @param {...!async.Step} var_args
 * @return {!async.Step}
 */
async.route = function(router, opt_decoder, var_args) {
  var args = opt_decoder instanceof Array ? opt_decoder :
      Array.prototype.slice.call(arguments, 1);

  /**
   * @this {async.Context}
   * @param {async.Input} input Идентификатор понятия.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function route(input, complete, cancel) {
    var context = this;

    /**
     * @param {!Array.<async.Output>} args
     */
    function localComplete(args) {
      router.apply(context, args).call(
          context, input, complete, cancel);
    }

    async.proc.parallel(args, async.output.ARRAY_COLLECTOR).call(
        context, input, localComplete, cancel);
  }

  return route;
};


/**
 * @param {function(...)} fn Заданная функция.
 * @param {...!async.Step} var_args
 * @return {!async.Step}
 */
async.combine = function(fn, var_args) {
  var args = Array.prototype.slice.call(arguments, 1);

  /**
   * @this {async.Context}
   * @param {async.Input} input Идентификатор понятия.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function combine(input, complete, cancel) {
    var context = this;

    /**
     * @param {!Array.<async.Output>} args
     */
    function localComplete(args) {
      var result = fn.apply(context, args);
      if (result !== undefined) {
        complete(result);
      } else {
        complete(null);
      }
    }

    async.proc.parallel(args, async.output.ARRAY_COLLECTOR).call(
        context, input, localComplete, cancel);
  }

  return combine;
};


/**
 * Создание шага переключения сценария.
 *
 * Переключение осуществляется за счет шага получения ключа, поиска
 * соответсвующего шага по таблице вызова и его выполнения.
 *
 * Результат шага получения ключа используется в качестве ключа в таблице
 * вызова.
 *
 * В случае если ключ отсутствует в таблице, вызывается соответсвующий шаг
 * по умолчанию.
 *
 * @see async.switch
 *
 * @param {!async.Step} condition Шаг получения ключа вызова.
 * @param {!Object.<*, !async.Step>} map Таблица вызова.
 * @param {!async.Step=} opt_default Шаг по-умолчанию, вызываемый в случае если
 *    ключ вызова отсутствует в теблице.
 * @return {!async.Step} Созданнй шаг.
 */
async.switch = function(condition, map, opt_default) {
  var nop = opt_default || async.nop;

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function step(input, complete, cancel) {
    var context = this;

    /**
     * @param {async.Output} key Данные.
     */
    function localComplete(key) {
      (map[key] || nop).call(context, input, complete, cancel);
    }

    condition.call(this, input, localComplete, cancel);
  }

  return step;
};


/**
 * Создание шага условного выполнения.
 *
 * @see async.switch
 *
 * @param {!async.ConditionStep} condition Шаг проверки услови.
 * @param {!async.Step} then Шаг выполняемый при успешном результате проверки.
 * @param {!async.Step=} opt_else Шаг вызываемый в случае, если результат
 *    проверки отрицательный.
 * @return {!async.Step} Созданнй шаг.
 */
async.if = function(condition, then, opt_else) {
  var elseStep = opt_else || async.nop;

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function step(input, complete, cancel) {
    var context = this;

    /**
     * @param {async.Output} output Данные.
     */
    function localComplete(output) {
      if (output) {
        then.call(context, input, complete, cancel);
      } else {
        elseStep.call(context, input, complete, cancel);
      }
    }

    condition.call(this, input, localComplete, cancel);
  }

  return step;
};


/**
 * Создание сценария циклического выполнения.
 *
 * Выполнение сценария заключается в повторении заданного шага. В качетве
 * входных данных шагу переддается результат его предыдущего выполнения.
 *
 * Входными данными первого вызова являются данные вызова созданного сценария.
 *
 * @param {!async.ConditionStep} condition Шаг проверки условия.
 * @param {!async.Step} step Повторяемый шаг.
 * @return {!async.Scenario} Созданный сценарий.
 */
async.while = function(condition, step) {

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function whileStep(input, complete, cancel) {
    var context = this;

    /**
     * @param {async.Output} output Данные.
     */
    function localComplete(output) {
      condition.call(context, output, function(result) {
        if (result) {
          step.call(context, output, localComplete, cancel);
        } else {
          complete(output);
        }
      }, cancel);
    }

    localComplete(input);
  }

  return whileStep;
};


/**
 * Создания сценария циклического выполнения соответвующего шага указанное
 * количесво раз.
 *
 * @see async.while
 *
 * @param {!async.Step} step Повторяемый шаг.
 * @param {number} count Количество повторений.
 * @return {!async.Scenario} Созданный сценарий.
 */
async.loop = function(step, count) {

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function loop(input, complete, cancel) {
    var context = this;
    var i = 0;

    /**
     * @param {async.Output} output Данные.
     */
    function localComplete(output) {
      if ((i += 1) > count) {
        complete(output);
      } else {
        step.call(context, output, localComplete, cancel);
      }
    }

    localComplete(input);
  }

  return loop;
};


/**
 * Шаг, в результат обработки которого передается текущий контекст.
 *
 * @this {async.Context}
 * @param {async.Input} input Входные данные.
 * @param {!async.CompleteHandler} complete Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.context = function(input, complete, cancel) {
  complete(this);
};


/**
 * Содание шага, привязывающего контекст созданный специальным шагом для
 * выполнения целевого.
 *
 * @param {!async.Step} actor Целевой шаг.
 * @param {!async.Step} isolator Шаг создания контекста.
 * @return {!async.Step} Созданный шаг.
 */
async.bind = function(actor, isolator) {

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function bind(input, complete, cancel) {

    /**
     * @param {async.Output} output Результат выполнения.
     */
    function localComplete(output) {
      actor.call(output, input, complete, cancel);
    }

    isolator.call(this, input, localComplete, cancel);
  }

  return bind;
};


/**
 * Создание шага, ошибки выполнения которого, не повлияют на выполнение
 * сценария, за счет отлова возникающих ошибок с помощью соответсвующей фабрики,
 * для которого указанный шаг будет целевым.
 *
 * @see async.FailCatcher
 * @see async.TolerantCatcher
 *
 * @param {!async.Step} actor Целевой шаг.
 * @param {!async.FailCatcher} failCatcher Создатель шага обработки.
 * @param {!async.TolerantCatcher=} opt_errorCatcher Создатель
 *    обработчика ошибки не влиябщего на выполнения сценария.
 * @return {!async.Step} Созданный шаг.
 */
async.try = function(actor, failCatcher, opt_errorCatcher) {
  var errorCatcher = opt_errorCatcher || async.NOP_CATCHER;

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function trying(input, complete, cancel) {
    var context = this;
    var errorHandler = null;

    /**
     * @param {async.Error} message Ошибка.
     * @param {number=} opt_code Код ошибки.
     */
    function localCancel(message, opt_code) {
      if (errorHandler === null) {
        errorHandler = errorCatcher.call(context);

        failCatcher.call(context, message, opt_code).call(
            context, input, complete, cancel);
      }

      errorHandler.call(context, message, opt_code);
    }

    actor.call(this, input, complete, localCancel);
  }

  return trying;
};


/**
 * Обертка для объевления шага в общем виде.
 *
 * @param {function(...)} strictActor Шаг с уточненными типами.
 * @return {!async.Step} Он же, объявленный в общем виде.
 */
async.esc = function(strictActor) {
  return strictActor;
};



/**
 * Интерфейс шага сценария.
 *
 * Шаг сценаря определяется состоянием контекста выполенния, входными данными и
 * результатом выполнения.
 *
 * Результатом выполенния шага является единственный вызов обработчика
 * результата либо более одного вызова обработчика ошибки.
 *
 * Обработчик результата принимает обязательный аргумент с результатом
 * выполнения.
 *
 * В случае не попадания шага под определение, ни одна из изпользующих его
 * функций не может обеспечить корректной работы.
 *
 * @see async.Input
 * @see async.Output
 * @see async.CompleteHandler
 * @see async.Step
 * @see async.Scenario
 * @see async.IStep#call
 *
 * @interface
 */
async.IStep = function() {};


/**
 * Выполнение шага.
 *
 * Вызов обработчика ошибки является признаком ошибки выполнения и влияет на
 * выполенние всего сценария.
 *
 * @see async.Scenario
 *
 * @param {async.Context} context Контекст выполнения.
 * @param {async.Input} input Входные данные.
 * @param {!async.CompleteHandler} complete Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.IStep.prototype.call = function(context, input, complete, cancel) {};




/**
 * @interface
 * @extends {async.IStep}
 */
async.IValue = function() {};


/**
 * @return {async.Input}
 */
async.IValue.prototype.getValue = function() {};


/**
 * @param {async.Input} value
 * @return {async.Input}
 */
async.IValue.prototype.setValue = function(value) {};


/**
 * @param {!async.Value} value
 * @return {boolean}
 */
async.IValue.prototype.isEqualTo = function(value) {};


/**
 * Создание шага присвоения значения переменной.
 *
 * @param {!async.Step=} opt_source Шаг получения входных данных.
 * @return {!async.Step} Созданный шаг.
 */
async.IValue.prototype.assign = function(opt_source) {};


/**
 * @return {!async.Step}
 */
async.IValue.prototype.exists = function() {};


/**
 * @return {!async.Step}
 */
async.IValue.prototype.notExists = function() {};


/**
 * @param {!async.Step} value Значение.
 * @return {!async.Step}
 */
async.IValue.prototype.equals = function(value) {};


/**
 * @param {!async.Step} value Значение.
 * @return {!async.Step}
 */
async.IValue.prototype.notEquals = function(value) {};



/**
 * @constructor
 * @implements {async.IValue}
 * @param {async.Input=} opt_value
 */
async.Value = function(opt_value) {
  var self = this;

  /**
   * @type {async.Input}
   */
  this.__value = opt_value === undefined ? null : opt_value;

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  this.__assign = function(input, complete, cancel) {
    complete(self.setValue(input));
  };

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  this.__exists = function(input, complete, cancel) {
    complete(self.getValue() !== null);
  };

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  this.__notExists = function(input, complete, cancel) {
    complete(self.getValue() !== null);
  };
};


/**
 * @override
 */
async.Value.prototype.call = function(context, input, complete, cancel) {
  complete(this.getValue());
};


/**
 * @override
 */
async.Value.prototype.assign = function(opt_source) {
  return async.use(this.__assign, opt_source);
};


/**
 * @override
 */
async.Value.prototype.exists = function() {
  return this.__exists;
};


/**
 * @override
 */
async.Value.prototype.notExists = function() {
  return this.__notExists;
};


/**
 * @override
 */
async.Value.prototype.equals = function(value) {
  var self = this;

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  return function(input, complete, cancel) {
    function localComplete(output) {
      complete(self.getValue() === output);
    }

    if (value instanceof async.Value) {
      complete(self.isEqualTo(value));
    } else {
      value.call(this, input, localComplete, cancel);
    }
  }
};


/**
 * @override
 */
async.Value.prototype.notEquals = function(value) {
  var self = this;

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  return function(input, complete, cancel) {
    function localComplete(output) {
      complete(self.getValue() !== output);
    }

    if (value instanceof async.Value) {
      complete(!self.isEqualTo(value));
    } else {
      value.call(this, input, localComplete, cancel);
    }
  }
};


/**
 * @override
 */
async.Value.prototype.getValue = function() {
  return this.__value;
};


/**
 * @override
 */
async.Value.prototype.setValue = function(value) {
  return this.__value = value;
};


/**
 * @override
 */
async.Value.prototype.isEqualTo = function(value) {
  return this.getValue() === value.getValue();
};



/**
 * @constructor
 * @param {!async.CompleteHandler} complete Обработчик результата итерации.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.Request = function(complete, cancel) {

  /**
   * @type {!async.CompleteHandler}
   */
  this.__complete = complete;

  /**
   * @type {!async.ErrorHandler}
   */
  this.__cancel = cancel;
};


/**
 * @param {async.Input} output результат.
 */
async.Request.prototype.complete = function(output) {
  this.__complete(output);
};


/**
 * @param {async.Error} error Ошибка.
 * @param {number=} opt_code Код ошибки.
 */
async.Request.prototype.cancel = function(error, opt_code) {
  this.__cancel(error, opt_code);
};


/**
 * Создание шага утверждения.
 *
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.fail = function(message, opt_code) {

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function assert(input, complete, cancel) {
    cancel(message, opt_code);
  }

  return assert;
};


/**
 * Создание шага утверждения.
 *
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.true = function(message, opt_code) {

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function assert(input, complete, cancel) {
    if (Boolean(input) === true) {
      complete(input);
    } else {
      cancel(message, opt_code);
    }
  }

  return assert;
};


/**
 * Создание шага утверждения.
 *
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.false = function(message, opt_code) {

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function assert(input, complete, cancel) {
    if (Boolean(input) === false) {
      complete(input);
    } else {
      cancel(message, opt_code);
    }
  }

  return assert;
};


/**
 * Создание шага утверждения.
 *
 * @param {async.Input} value Занчение.
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.equals = function(value, message, opt_code) {

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function assert(input, complete, cancel) {
    if (input === value) {
      complete(input);
    } else {
      cancel(message, opt_code);
    }
  }

  return assert;
};


/**
 * Создание шага утверждения.
 *
 * @param {async.Input} value Занчение.
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.notEquals = function(value, message, opt_code) {

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function assert(input, complete, cancel) {
    if (input !== value) {
      complete(input);
    } else {
      cancel(message, opt_code);
    }
  }

  return assert;
};


/**
 * Создание шага утверждения.
 *
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.null = function(message, opt_code) {

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function assert(input, complete, cancel) {
    if (input === null) {
      complete(input);
    } else {
      cancel(message, opt_code);
    }
  }

  return assert;
};


/**
 * Создание шага утверждения.
 *
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.notNull = function(message, opt_code) {

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function assert(input, complete, cancel) {
    if (input !== null) {
      complete(input);
    } else {
      cancel(message, opt_code);
    }
  }

  return assert;
};


/**
 * Создание шага утверждения.
 *
 * @param {string|!Function} type Тип.
 * @param {string} message Ошибка.
 * @param {number=} opt_code Код ошибки.
 * @return {!async.Step} Созданный шаг.
 */
async.assert.type = function(type, message, opt_code) {

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function assert(input, complete, cancel) {
    if (typeof type === 'string' && typeof input === type ||
        typeof type === 'function' && input instanceof type) {
      complete(input);
    } else {
      cancel(message, opt_code);
    }
  }

  return assert;
};


/**
 * Сценарий, задачей которого является обработка входных данных с помощью
 * соответсвующих шагов и сбор результатов выполнения.
 *
 * В каждый шаг такого сценария будут переданы входные данные.
 *
 * В качетве накопителя по умолчанию для всех создаваемых сценариев будет
 * выбран создатель игнорирующего накопителя `async.output.NOP_COLLECTOR`.
 *
 * @see async.Step
 * @see async.Parallel
 * @see async.Sequence
 * @see async.output.ICollector
 * @see async.output.NopCollector
 *
 * @typedef {async.Scenario}
 */
async.proc.Scenario;


/**
 * Создание сценария параллельной обработки входных данных
 * заднным набором шагов.
 *
 * Для созданного сценария правилом параллельного вызова будет вызов шагов
 * сценария прямым перебором. Без передачи данных от шага к шагу.
 *
 * @see async.Parallel
 * @see async.proc.Scenario
 * @see async.output.ICollector
 *
 * @param {!Array.<!async.Step>} steps Набор шагов.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @return {!async.proc.Scenario} Созданный сценарий.
 */
async.proc.parallel = function(steps, opt_collector) {
  var acc = opt_collector || async.output.NOP_COLLECTOR;

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function parallel(input, complete, cancel) {
    var collector = acc.call(this, input);
    var context = this;
    var c = steps.length;

    /**
     * @param {async.Output} output Результат выполнения.
     */
    function localComplete(output) {
      collector.add(output, context);

      if (c > 0) {
        c -= 1;
      } else {
        complete(collector.get());
      }
    }

    var i = 0,
        l = steps.length;

    while (i < l) {
      steps[i].call(context, input, localComplete, cancel);

      i += 1;
    }

    if (c > 0) {
      c -= 1;
    } else {
      complete(collector.get());
    }
  }

  return parallel;
};


/**
 * Создание сценария последовательной обработки входных даных
 * заданным набором шагов.
 *
 * Входные данные шага проверки условия - данные промежуточного
 * результата выполнения созданного сценария.
 *
 * @see async.Sequence
 * @see async.proc.Scenario
 * @see async.output.ICollector
 * @see async.ConditionStep
 *
 * @param {!Array.<!async.Step>} steps Набор шагов.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @param {!async.ConditionStep=} opt_condition Шаг проверки условия
 *    продолжения последовательности.
 * @return {!async.proc.Scenario} Созданный сценарий.
 */
async.proc.sequence = function(steps, opt_collector, opt_condition) {
  var condition = opt_condition || async.IS_INPUT;
  var acc = opt_collector || async.output.NOP_COLLECTOR;

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function sequence(input, complete, cancel) {
    var collector = acc.call(this, input);
    var context = this;
    var l = steps.length - 1;
    var i = -1;

    /**
     * @param {async.Error} error Ошибка.
     * @param {number=} opt_code Код ошибки.
     */
    function localCancel(error, opt_code) {
      i = l;
      cancel(error, opt_code);
    }

    /**
     * @param {boolean} result Результат проверки условия продолжения.
     */
    function process(result) {
      if (i < l && result) {
        steps[i += 1].call(context, input, localComplete, localCancel);
      } else {
        complete(collector.get());
      }
    }

    /**
     * @param {async.Output} output Результат выполнения.
     */
    function localComplete(output) {
      collector.add(output, context);
      condition.call(context, collector.get(), process, localCancel);
    }

    process(true);
  }

  return sequence;
};


/**
 * Создание сценария обработки входных данных единственным шагом.
 *
 * @param {!async.Step} step Выбранный шаг.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @return {!async.proc.Scenario} Созданный сценарий.
 */
async.proc.one = function(step, opt_collector) {
  var acc = opt_collector || async.output.NOP_COLLECTOR;

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function one(input, complete, cancel) {
    var collector = acc.call(this, input);
    var context = this;

    /**
     * @param {async.Output} output Результат выполнения.
     */
    function localComplete(output) {
      collector.add(output, context);
      complete(collector.get());
    }

    step.call(this, input, localComplete, cancel);
  }

  return one;
};


/**
 * Создание сценария обработки входных данных единственным шагом заданное
 * количество раз.
 *
 * @param {async.Step} step Шаг.
 * @param {number} count Количество повторений.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @return {!async.proc.Scenario} Созданный сценарий.
 */
async.proc.loop = function(step, count, opt_collector) {
  var acc = opt_collector || async.output.NOP_COLLECTOR;

  /**
   * @this {async.Context}
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function loop(input, complete, cancel) {
    var collector = acc.call(this, input);
    var context = this;
    var i = 0;

    /**
     * @param {async.Output} output Данные.
     */
    function localComplete(output) {
      collector.add(output, context);

      if ((i += 1) >= count) {
        complete(collector.get());
      } else {
        step.call(context, input, localComplete, cancel);
      }
    }

    step.call(context, input, localComplete, cancel);
  }

  return loop;
};


/**
 * Сценарий, задачей которого является обработка элементов входного набора
 * данных с помощью соответсвующих шагов и сбор результатов выполнения.
 *
 * В каждый из соответсвующего набора шагов такого сценария будет передан
 * элемент входного набора данных.
 *
 * В качетве накопителя по умолчанию для всех создаваемых сценариев будет
 * выбран создатель собирающего накопителя `async.output.FLAT_COLLECTOR`.
 *
 * @see async.IStep
 * @see async.input.DataSet
 * @see async.input.IIterator
 * @see async.output.ICollector
 * @see async.output.FlatCollector
 *
 * @typedef {async.proc.Scenario}
 */
async.proc.fold.Scenario;


/**
 * Создание сценария параллельной обработки каждого элемента входного набора
 * данных с помощью соответсвующего шага.
 *
 * @see async.Parallel
 * @see async.proc.fold.Scenario
 * @see async.input.IIterator
 * @see async.output.ICollector
 *
 * @param {!async.Step} handler Шаг обработки.
 * @param {!async.input.IteratorCreator=} opt_iterator Создатель итератора
 *    входного набора данных.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @return {!async.proc.fold.Scenario} Созданный сценарий.
 */
async.proc.fold.parallel = function(handler, opt_iterator, opt_collector) {
  var acc = opt_collector || async.output.FLAT_COLLECTOR;
  var it = opt_iterator || async.input.ARRAY_ITERATOR;

  /**
   * @this {async.Context}
   * @param {async.input.DataSet} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function parallel(input, complete, cancel) {
    var iterator = it.call(this, input);
    var collector = acc.call(this, input);
    var context = this;
    var c = 0;
    var i = -1;

    /**
     * @param {async.Error} error Ошибка.
     * @param {number=} opt_code Код ошибки.
     */
    function localCancel(error, opt_code) {
      iterator.destroy();
      cancel(error, opt_code);
    }


    /**
     * @param {async.Input=} opt_next Имеется ли еще данные.
     * @param {async.Context=} opt_context Контекст.
     */
    function step(opt_next, opt_context) {
      var stepContext = opt_context === undefined ? context : opt_context;

      /**
       * @param {async.Output} output Результат выполнения.
       */
      function localComplete(output) {
        collector.add(output, stepContext);

        if (c === (i += 1)) {
          iterator.destroy();
          complete(collector.get());
        }
      }

      if (opt_next === undefined) {
        if (c === (i += 1)) {
          iterator.destroy();
          complete(collector.get());
        }
      } else {
        c += 1;
        handler.call(stepContext, opt_next, localComplete, localCancel);

        iterator.next(step, localCancel);
      }
    }

    iterator.next(step, localCancel);
  }

  return parallel;
};


/**
 * Создание сценария последовательной обработки входных даных заданным набором
 * шагов.
 *
 * Входными данными шага проверки условия будет промежуточный результат
 * выполнения созданного сценария.
 *
 * @see async.Sequence
 * @see async.proc.fold.Scenario
 * @see async.input.IIterator
 * @see async.output.ICollector
 * @see async.ConditionStep
 *
 * @param {!async.Step} handler Шаг обработки.
 * @param {!async.input.IteratorCreator=} opt_iterator Создатель итератора
 *    входного набора данных.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @param {!async.ConditionStep=} opt_condition Шаг проверки условия
 *    продолжения последовательности.
 * @return {!async.proc.fold.Scenario} Созданный сценарий.
 */
async.proc.fold.sequence = function(handler, opt_iterator, opt_collector,
                                    opt_condition) {
  var acc = opt_collector || async.output.FLAT_COLLECTOR;
  var it = opt_iterator || async.input.ARRAY_ITERATOR;
  var condition = opt_condition || async.IS_INPUT;

  /**
   * @this {async.Context}
   * @param {async.input.DataSet} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function sequence(input, complete, cancel) {
    var iterator = it.call(this, input);
    var collector = acc.call(this, input);
    var context = this;

    /**
     * @param {async.Input=} opt_next Имеется ли еще данные.
     * @param {async.Context=} opt_context Контекст.
     */
    function step(opt_next, opt_context) {
      var stepContext = opt_context === undefined ? context : opt_context;

      /**
       * @param {async.Output} output Результат выполнения.
       */
      function localComplete(output) {
        collector.add(output, stepContext);
        condition.call(context, collector.get(), process, localCancel);
      }

      if (opt_next !== undefined) {
        handler.call(stepContext, opt_next, localComplete, localCancel);
      } else {
        iterator.destroy();
        complete(collector.get());
      }
    }

    /**
     * @param {boolean} result Результат проверки условия продолжения.
     */
    function process(result) {
      if (result) {
        iterator.next(step, localCancel);
      } else {
        iterator.destroy();
        complete(collector.get());
      }
    }

    /**
     * @param {async.Error} error Ошибка.
     * @param {number=} opt_code Код ошибки.
     */
    function localCancel(error, opt_code) {
      iterator.destroy();

      cancel(error, opt_code);
    }

    process(true);
  }

  return sequence;
};


/**
 * Сценарий, задачей которого является обработка элементов входного набора
 * данных с помощью соответсвенного набора шагов и сбор результатов выполнения.
 *
 * В каждый из соответсвующего набора шагов такого сценария будет передан
 * соответсвующий элемент входного набора данных.
 *
 * В качестве накопителя по умолчанию для всех создаваемых сценариев будет
 * выбран создатель собирающего накопителя `async.output.ARRAY_COLLECTOR`.
 *
 * @see async.IStep
 * @see async.input.DataSet
 * @see async.input.IIterator
 * @see async.output.ICollector
 * @see async.output.ArrayCollector
 *
 * @typedef {async.proc.Scenario}
 */
async.proc.zip.Scenario;


/**
 * Создание сценария параллельной обработки каждого элемента входного набора
 * данных с помощью соответсвующих шагов.
 *
 * @see async.Parallel
 * @see async.proc.zip.Scenario
 * @see async.input.IIterator
 * @see async.output.ICollector
 *
 * @param {!Array.<!async.Step>} steps Набор шагов.
 * @param {!async.input.IteratorCreator=} opt_iterator Создатель итератора
 *    входного набора данных.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @return {!async.proc.zip.Scenario} Созданный сценарий.
 */
async.proc.zip.parallel = function(steps, opt_iterator, opt_collector) {
  var acc = opt_collector || async.output.ARRAY_COLLECTOR;
  var it = opt_iterator || async.input.ARRAY_ITERATOR;

  /**
   * @this {async.Context}
   * @param {!async.input.DataSet} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function parallel(input, complete, cancel) {
    var iterator = it.call(this, input);
    var collector = acc.call(this, input);
    var context = this;
    var c = 0;
    var i = -1;


    /**
     * @param {async.Error} error Ошибка.
     * @param {number=} opt_code Код ошибки.
     */
    function localCancel(error, opt_code) {
      iterator.destroy();
      cancel(error, opt_code);
    }


    /**
     * @param {async.Input=} opt_next Имеется ли еще данные.
     * @param {async.Context=} opt_context Контекст.
     */
    function step(opt_next, opt_context) {

      /**
       * @param {async.Output} output Результат выполнения.
       */
      function localComplete(output) {
        collector.add(output, opt_context);

        if (c === (i += 1)) {
          iterator.destroy();
          complete(collector.get());
        }
      }

      if (opt_next === undefined || (steps[c] === undefined)) {
        if (c === (i += 1)) {
          iterator.destroy();
          complete(collector.get());
        }
      } else {
        c += 1;
        steps[c - 1].call(opt_context === undefined ? context : opt_context,
            opt_next, localComplete, localCancel);

        iterator.next(step, localCancel);
      }
    }

    iterator.next(step, localCancel);
  }

  return parallel;
};


/**
 * Создание сценария последовательной обработки входных даных заданным набором
 * шагов.
 *
 * Входными данными шага проверки условия будет промежуточный результат
 * выполнения созданного сценария.
 *
 * @see async.Sequence
 * @see async.proc.zip.Scenario
 * @see async.input.IIterator
 * @see async.output.ICollector
 *
 * @param {!Array.<!async.Step>} steps Набор шагов.
 * @param {!async.input.IteratorCreator=} opt_iterator Создатель итератора
 *    входного набора данных.
 * @param {!async.output.CollectorCreator=} opt_collector Создатель накопителя
 *    результатов.
 * @param {!async.ConditionStep=} opt_condition Шаг проверки условия
 *    продолжения последовательности.
 * @return {!async.proc.zip.Scenario} Созданный сценарий.
 */
async.proc.zip.sequence = function(steps, opt_iterator, opt_collector,
                                   opt_condition) {
  var acc = opt_collector || async.output.FLAT_COLLECTOR;
  var it = opt_iterator || async.input.ARRAY_ITERATOR;
  var condition = opt_condition || async.IS_INPUT;

  /**
   * @this {async.Context}
   * @param {!async.input.DataSet} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function sequence(input, complete, cancel) {
    var iterator = it.call(this, input);
    var collector = acc.call(this, input);
    var context = this;
    var i = 0;

    /**
     * @param {async.Input=} opt_next Имеется ли еще данные.
     * @param {async.Context=} opt_context Контекст.
     */
    function step(opt_next, opt_context) {
      var stepContext = opt_context === undefined ? context : opt_context;

      /**
       * @param {async.Output} output Результат выполнения.
       */
      function localComplete(output) {
        i += 1;

        collector.add(output, stepContext);
        condition.call(context, collector.get(), process, localCancel);
      }

      if (opt_next !== undefined) {
        steps[i].call(stepContext, opt_next, localComplete, localCancel);
      } else {
        iterator.destroy();
        complete(collector.get());
      }
    }

    /**
     * @param {boolean} result Результат проверки условия продолжения.
     */
    function process(result) {
      if (result && steps[i] !== undefined) {
        iterator.next(step, localCancel);
      } else {
        iterator.destroy();
        complete(collector.get());
      }
    }

    /**
     * @param {async.Error} error Ошибка.
     * @param {number=} opt_code Код ошибки.
     */
    function localCancel(error, opt_code) {
      iterator.destroy();
      cancel(error, opt_code);
    }

    process(true);
  }

  return sequence;
};


/**
 * Все, что может выступать в качетсве набора данных.
 *
 * Набор данных определяется возможностью итерировать по его элементам.
 *
 * @see async.input.IIterator
 * @see async.input.IteratorCreator
 *
 * @typedef {async.Input}
 */
async.input.DataSet;


/**
 * Создатель нового итератора по набору данных.
 *
 * Создатель вызывается в контексте сценария и в качетве аргумента создатель
 * принимает входной набор данных шага сценария.
 *
 * Результатом создания является итератор по соотвесвующему набору данных.
 *
 * @typedef {?function(async.input.DataSet):!async.input.IIterator}
 */
async.input.IteratorCreator;


/**
 * Создатель итератора по объекту `Array`.
 *
 * Если входной набор данных не будет являтся массивом, для итератора это будет
 * эквиваленно массиву из одного элемента, за исключением объекта `null` - его
 * эквивалентом для итератора будет пустой массив.
 *
 * @param {async.input.DataSet} input Входной набор данных шага.
 * @return {!async.input.IIterator} Итератор по набору данных.
 */
async.input.ARRAY_ITERATOR = function(input) {
  if (input instanceof Array) {
    return new async.input.ArrayIterator(input);
  } else if (input !== null) {
    return new async.input.RepeatIterator(input, 1);
  }

  return new async.input.NopIterator();
};


/**
 * @param {async.input.DataSet} input Входной набор данных шага.
 * @return {!async.input.IIterator} Итератор по набору данных.
 */
async.input.KEY_ITERATOR = function(input) {
  if (input instanceof Object) {
    return new async.input.KeyIterator(input);
  }

  return new async.input.NopIterator();
};


/**
 * Создатель итератора повторяющего входные данные.
 *
 * @param {number} count Количество повторений входных данных
 * @return {!async.input.IteratorCreator}
 */
async.input.REPEAT_ITERATOR = function(count) {

  /**
   * @param {async.input.DataSet} input Входной набор данных шага.
   * @return {!async.input.IIterator} Итератор по набору данных.
   */
  return function(input) {
    return new async.input.RepeatIterator(input, count);
  };
};


/**
 * Обертка для объявления создателя итератора в общем виде.
 *
 * @param {function(...)} strictCreator Создатель итератора с уточненными
 *    типами.
 * @return {!async.input.IteratorCreator} Он же, объявленный в общем виде.
 */
async.input.escIterator = function(strictCreator) {
  return strictCreator;
};




/**
 * Интерфейс итератора набора данных.
 *
 * @see async.input.DataSet
 *
 * @interface
 */
async.input.IIterator = function() {};


/**
 * Шаг итерации.
 *
 * Результатом итерации является вызов указанного обработчика.
 *
 * При вызове обработчика с одним аргументом его значением являтся экземляр
 * типа данных, соответсвующего набору. Вызов обработчика без аргументов
 * указывает на завершение итерирования и является указанием к уничтожению
 * итератора - уничтожение не происходит автоматически.
 *
 * @see async.input.IIterator#destroy
 *
 * @param {function(async.Input=, async.Context=)} complete Обработчик
 *    результата итерации.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.input.IIterator.prototype.next = function(complete, cancel) {};


/**
 * Уничтожение итератора.
 */
async.input.IIterator.prototype.destroy = function() {};



/**
 * Итератор по массиву реализованному экземпляром стандартного типа `Array`.
 *
 * @constructor
 * @implements {async.input.IIterator}
 */
async.input.NopIterator = function() {};


/**
 * @override
 */
async.input.NopIterator.prototype.next = function(complete, cancel) {
  complete();
};


/**
 * @override
 */
async.input.NopIterator.prototype.destroy = function() {};



/**
 * Итератор по массиву реализованному экземпляром стандартного типа `Array`.
 *
 * @constructor
 * @implements {async.input.IIterator}
 * @param {!Array.<async.Input>} input Входные данные выполнения шага.
 */
async.input.ArrayIterator = function(input) {

  /**
   * @type {!Array.<async.Input>}
   */
  this.__core = input;

  /**
   * @type {number}
   */
  this.__index = this.__core.length;
};


/**
 * @override
 */
async.input.ArrayIterator.prototype.next = function(complete, cancel) {
  if ((this.__index -= 1) >= 0) {
    complete(this.__core[this.__index]);
  } else {
    complete();
  }
};


/**
 * @override
 */
async.input.ArrayIterator.prototype.destroy = function() {
  this.__index = 0;
};



/**
 * Итератор повторяющий входные данные.
 *
 * @constructor
 * @implements {async.input.IIterator}
 * @param {async.Input} input Входные данные выполнения шага.
 * @param {number} count Количество повторений входных данных.
 */
async.input.RepeatIterator = function(input, count) {

  /**
   * @type {async.Input}
   */
  this.__input = input;

  /**
   * @type {number}
   */
  this.__index = count;
};


/**
 * @override
 */
async.input.RepeatIterator.prototype.next = function(complete, cancel) {
  if ((this.__index -= 1) >= 0) {
    complete(this.__input);
  } else {
    complete();
  }
};


/**
 * @override
 */
async.input.RepeatIterator.prototype.destroy = function() {
  this.__index = 0;
};



/**
 * Итератор по массиву реализованному экземпляром стандартного типа `Array`.
 *
 * @constructor
 * @extends {async.input.ArrayIterator}
 * @param {!Object} input Входные данные выполнения шага.
 */
async.input.KeyIterator = function(input) {
  async.input.ArrayIterator.call(this, Object.keys(input) || []);
};

util.inherits(async.input.KeyIterator, async.input.ArrayIterator);


/**
 * @typedef {number}
 */
async.input.cursor.Position;


/**
 * @type {number}
 */
async.input.cursor.START_POSITION = 0;


/**
 * @type {number}
 */
async.input.cursor.STOP_POSITION = -1;



/**
 * @interface
 */
async.input.cursor.ICursor = function() {};


/**
 * @param {async.input.cursor.Position} position Позиция.
 * @param {function(async.input.cursor.Position, !Array.<async.Input>)} complete
 *    Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.input.cursor.ICursor.prototype.next =
    function(position, complete, cancel) {};



/**
 * @constructor
 * @implements {async.input.IIterator}
 * @param {!async.input.cursor.ICursor} cursor Итератор.
 */
async.input.cursor.Iterator = function(cursor) {
  var self = this;

  /**
   * @type {!async.input.cursor.ICursor}
   */
  this.__cursor = cursor;

  /**
   * @type {async.input.cursor.Position}
   */
  this.__position = async.input.cursor.START_POSITION;

  /**
   * @type {!Array.<!Array.<async.Input>>}
   */
  this.__table = [];

  /**
   * @type {number}
   */
  this.__currentCell = -1;

  /**
   * @type {!Array.<!async.input.cursor.Request>}
   */
  this.__requests = [];

  /**
   * @type {boolean}
   */
  this.__isInProcess = false;

  /**
   * @type {undefined|async.Error}
   */
  this.__errorMessage = undefined;

  /**
   * @type {undefined|number}
   */
  this.__errorCode = undefined;

  /**
   * @param {async.input.cursor.Position} position Новая позиция.
   * @param {!Array.<async.Input>} chunk Подмножество.
   */
  this.__handleNext = function(position, chunk) {
    self.__isInProcess = false;
    self.__position = position;

    if (chunk.length > 0) {
      self.__table.push(chunk);
    }

    self.__flushResult();
  };

  /**
   * @param {async.Error} message Ошибка.
   * @param {number=} opt_code Код ошибки.
   */
  this.__handleError = function(message, opt_code) {
    self.__isInProcess = false;
    self.__errorMessage = message;
    self.__errorCode = opt_code;
    self.__flushError();
  };
};


/**
 * @override
 */
async.input.cursor.Iterator.prototype.next = function(complete, cancel) {
  this.__requests.push(new async.input.cursor.Request(complete, cancel));

  if (this.__errorMessage === undefined) {
    this.__flushResult();
  } else {
    this.__flushError();
  }
};


/**
 * Уничтожение итератора.
 */
async.input.cursor.Iterator.prototype.destroy = function() {
  this.__position = async.input.cursor.STOP_POSITION;
  this.__requests.length = 0;
  this.__table.length = 0;
  this.__errorMessage = '';
};


/**
 * @return {boolean} Имеется ли следующий элемент.
 */
async.input.cursor.Iterator.prototype.__canFlush = function() {
  return this.__position === async.input.cursor.STOP_POSITION ||
      this.__table.length > 1 || (this.__table.length === 1 &&
          this.__currentCell < this.__table[0].length - 1);
};


/**
 *
 */
async.input.cursor.Iterator.prototype.__flushResult = function() {
  while (this.__requests.length > 0 && this.__canFlush()) {
    var request = this.__requests.shift();

    var row = this.__table[0];
    while (row !== undefined && this.__currentCell >= row.length - 1) {
      this.__currentCell = -1;
      this.__table.shift();

      row = this.__table[0];
    }

    if (row !== undefined) {
      request.complete(row[this.__currentCell += 1]);
    } else {
      request.complete();
    }
  }

  if (this.__requests.length > 0 && !this.__isInProcess) {
    this.__isInProcess = true;
    this.__cursor.next(this.__position, this.__handleNext, this.__handleError);
  }
};


/**
 *
 */
async.input.cursor.Iterator.prototype.__flushError = function() {
  while (this.__requests.length > 0) {
    this.__requests.shift().cancel(this.__errorMessage, this.__errorCode);
  }
};



/**
 * @constructor
 * @param {function(async.Input=)} complete Обработчик результата итерации.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.input.cursor.Request = function(complete, cancel) {

  /**
   * @type {function(async.Input=)}
   */
  this.__complete = complete;

  /**
   * @type {!async.ErrorHandler}
   */
  this.__cancel = cancel;
};


/**
 * @param {async.Input=} opt_output результат.
 */
async.input.cursor.Request.prototype.complete = function(opt_output) {
  this.__complete(opt_output);
};


/**
 * @param {async.Error} error Ошибка.
 * @param {number=} opt_code Код ошибки.
 */
async.input.cursor.Request.prototype.cancel = function(error, opt_code) {
  this.__cancel(error, opt_code);
};



/**
 * @constructor
 * @implements {async.input.cursor.ICursor}
 *
 * @param {!async.input.cursor.ICursor} cursor Wrapped cursor.
 */
async.input.cursor.cache.Cursor = function(cursor) {

  var self = this;

  /**
   * @type {!async.input.cursor.ICursor}
   */
  this.__cursor = cursor;

  /**
   * @type {Array}
   */
  this.__requestQueue = [];

  /**
   * @type {number}
   */
  this.__position = async.input.cursor.START_POSITION;

  /**
   * @type {!Array.<!Array.<async.Input>>}
   */
  this.__cache = [];

  /**
   * @type {undefined|async.Error}
   */
  this.__errorMessage = undefined;

  /**
   * @type {undefined|number}
   */
  this.__errorCode = undefined;

  /**
   * @param {async.input.cursor.Position} position
   * @param {!Array.<async.Input>} result
   */
  this.__cursorHandler = function(position, result) {
    self.__position = position;
    self.__cache.push(result);

    self.__flushQueue();
  };

  /**
   * @param {async.Error} message Ошибка.
   * @param {number=} opt_code Код ошибки.
   */
  this.__handleError = function(message, opt_code) {
    self.__position = async.input.cursor.STOP_POSITION;
    self.__errorMessage = message;
    self.__errorCode = opt_code;
    self.__flushError();
  };
};


/**
 * @override
 */
async.input.cursor.cache.Cursor.prototype.next =
    function(position, complete, cancel) {

  if (this.__errorMessage === undefined) {
    this.__requestQueue.push(new async.input.cursor.cache.Request(
        position, complete, cancel));

    if (this.__requestQueue.length === 1) {
      this.__flushQueue();
    }
  } else {
    cancel(this.__errorMessage, this.__errorCode);
  }
};


/**
 * Push response for request from queue
 */
async.input.cursor.cache.Cursor.prototype.__flushQueue = function() {
  var i = 0;
  while (this.__requestQueue[i] !== undefined) {
    var request = this.__requestQueue[i];

    var chunk = this.__cache[request.getPosition()];
    if (chunk !== undefined) {
      request.complete(chunk);
      this.__requestQueue.splice(i, 1);
    } else if (this.__position === async.input.cursor.STOP_POSITION) {
      request.complete(this.__position, []);
      this.__requestQueue.splice(i, 1);
    } else {
      i += 1;
    }
  }

  if (this.__requestQueue.length > 0) {
    this.__cursor.next(this.__position,
        this.__cursorHandler, this.__handleError);
  }
};


/**
 * Flush queue with errors;
 */
async.input.cursor.cache.Cursor.prototype.__flushError = function() {
  this.__cache = [];

  while (this.__requestQueue.length > 0) {
    this.__requestQueue.shift().cancel(
        this.__errorMessage, this.__errorCode);
  }
};



/**
 * @constructor
 *
 * @param {async.input.cursor.Position} position Позиция.
 * @param {function(async.input.cursor.Position, !Array.<async.Input>)} complete
 *    Обработчик результата.
 * @param {!async.ErrorHandler} cancel Обработчик ошибки.
 */
async.input.cursor.cache.Request = function(position, complete, cancel) {

  /**
   * @type {async.input.cursor.Position}
   */
  this.__position = position;

  /**
   * @type {function(async.input.cursor.Position, !Array.<async.Input>)}
   * complete
   */
  this.__complete = complete;

  /**
   * @type {!async.ErrorHandler}
   */
  this.__cancel = cancel;
};


/**
 * @param {async.input.cursor.Position} position Позиция.
 * @param {!Array.<async.Input>} data
 */
async.input.cursor.cache.Request.prototype.complete = function(position, data) {
  this.__complete(position, data);
};


/**
 * @param {string} error Ошибка.
 * @param {number=} opt_code Код ошибки.
 */
async.input.cursor.cache.Request.prototype.cancel = function(error, opt_code) {
  this.__cancel(error, opt_code);
};


/**
 * @return {async.input.cursor.Position}
 */
async.input.cursor.cache.Request.prototype.getPosition = function() {
  return this.__position;
};



/**
 * @constructor
 * @implements {async.input.cursor.ICursor}
 *
 * @param {!async.input.cursor.ICursor} cursor Wrapped cursor.
 * @param {!async.Step} filter Фильтр элемента множества.
 * @param {async.Context} context
 * @param {async.Input=} opt_null
 */
async.input.cursor.filter.Cursor = function(cursor, filter, context, opt_null) {

  /**
   * @type {!async.input.cursor.ICursor}
   */
  this.__cursor = cursor;

  /**
   * @type {!async.Step}
   */
  this.__filter = async.proc.fold.parallel(filter,
      async.input.ARRAY_ITERATOR, async.output.FILTER_COLLECTOR(opt_null));

  /**
   * @type {async.Context}
   */
  this.__context = context;
};


/**
 * @override
 */
async.input.cursor.filter.Cursor.prototype.next =
    function(position, complete, cancel) {
  var self = this;

  /**
   * @param {async.input.cursor.Position} position Позиция.
   * @param {!Array.<async.Input>} chunk
   */
  function filter(position, chunk) {
    self.__filter.call(self.__context, chunk, function(chunk) {
      complete(position, chunk);
    }, cancel);
  }

  this.__cursor.next(position, filter, cancel);
};



/**
 * Коллекционер собирающий результаты в массив, разворациячивая вложенные
 * массивы и игнорируя значение `null`.
 *
 * Данный накопитель удобен при обобщенной работе с множествами.
 *
 * @constructor
 * @implements {async.output.ICollector}
 */
async.output.FlatCollector = function() {

  /**
   * @type {!Array.<*>}
   */
  this.__result = [];
};


/**
 * @override
 */
async.output.FlatCollector.prototype.add = function(data) {
  if (data !== null) {
    if (data instanceof Array) {
      for (var i = 0, l = data.length; i < l; i += 1) {
        this.add(data[i]);
      }
    } else {
      this.__result.push(data);
    }
  }
};


/**
 * @override
 */
async.output.FlatCollector.prototype.get = function() {
  return this.__result;
};



/**
 * @constructor
 * @implements {async.output.ICollector}
 * @param {async.Input=} opt_null
 */
async.output.FilterCollector = function(opt_null) {

  /**
   * @type {!Array.<!async.Input>}
   */
  this.__result = [];

  /**
   * @type {async.Input}
   */
  this.__null = opt_null === undefined ? null : opt_null;
};


/**
 * @override
 */
async.output.FilterCollector.prototype.add = function(data) {
  if (data !== this.__null) {
    this.__result.push(data);
  }
};


/**
 * @override
 */
async.output.FilterCollector.prototype.get = function() {
  return this.__result;
};



/**
 * Интерфейс коллекционера результатов обработки.
 *
 * Объекты реализующие данный интерфейс могут выступать в качестве накопителей
 * и обработчиков результатов выполнения шагов обрабатывающих сценариев.
 *
 * @see async.output.CollectorCreator
 * @see async.proc.Scenario
 *
 * @interface
 */
async.output.ICollector = function() {};


/**
 * Добавление результата выполнения шага в коллекцию.
 *
 * @param {async.Output} data Результат выполнения шага.
 * @param {async.Context} context Контекст выполнения шага.
 */
async.output.ICollector.prototype.add = function(data, context) {};


/**
 * Возвращение текущего результата.
 *
 * @return {async.Output} Результат накопления.
 */
async.output.ICollector.prototype.get = function() {};


/**
 * Создатель коллекционера результатов обработки.
 *
 * Создатель вызывается в контексте сценария и получает в качетве аргумента
 * входные данные соотвествующего шага для модификации коллекционера.
 *
 * Резузльтатом создания является объект реализующий интерфейс колекционера
 * результата, для использования в сценраии.
 *
 * @see async.Input
 * @see async.output.ICollector
 * @see async.proc.Scenario
 *
 * @typedef {?function(async.Input):!async.output.ICollector}
 */
async.output.CollectorCreator;


/**
 * Обертка для объявления создателя накопителя в общем виде.
 *
 * @param {function(...)} strictCreator Создатель накопителя с уточненными
 *    типами.
 * @return {!async.output.CollectorCreator} Он же, объявленный в общем виде.
 */
async.output.escCollector = function(strictCreator) {
  return strictCreator;
};


/**
 * Создатель коллекционера игнорирующего результаты.
 *
 * @param {async.Input} input Входные данные шага.
 * @return {!async.output.ICollector} Коллекционер результата.
 */
async.output.NOP_COLLECTOR = function(input) {
  return new async.output.NopCollector(input);
};


/**
 * Создатель коллекционера игнорирующего результаты.
 *
 * @param {async.Input} input Входные данные шага.
 * @return {!async.output.ICollector} Коллекционер результата.
 */
async.output.NULL_COLLECTOR = function(input) {
  return new async.output.NullCollector();
};


/**
 * Создатель коллекционера собирающего результаты в массив.
 *
 * Не зависит от входных данных.
 *
 * @param {async.Input} input Входные данные шага.
 * @return {!async.output.ICollector} Коллекционер результата.
 */
async.output.ARRAY_COLLECTOR = function(input) {
  return new async.output.ArrayCollector();
};


/**
 * Создатель коллекционера собирающего результаты в массив игнорирующего `null`
 * и разврачивающего вложенные.
 *
 * Не зависит от входных данных.
 *
 * @param {async.Input} input Входные данные шага.
 * @return {!async.output.ICollector} Коллекционер результата.
 */
async.output.FLAT_COLLECTOR = function(input) {
  return new async.output.FlatCollector();
};


/**
 * Создатель коллекционера собирающего последнйи результат.
 *
 * Не зависит от входных данных.
 *
 * @param {async.Input} input Входные данные шага.
 * @return {!async.output.ICollector} Коллекционер результата.
 */
async.output.ONE_COLLECTOR = function(input) {
  return new async.output.OneCollector();
};


/**
 * Создатель коллекционера.
 *
 * @param {async.Input} input Входные данные шага.
 * @return {!async.output.ICollector} Коллекционер результата.
 */
async.output.AND_COLLECTOR = function(input) {
  return new async.output.AndCollector();
};


/**
 * @param {async.Input=} opt_null
 * @return {!async.output.CollectorCreator} Коллекционер результата.
 */
async.output.FILTER_COLLECTOR = function(opt_null) {

  /**
   * @param {async.Input} input Входные данные шага.
   * @return {!async.output.ICollector} Коллекционер результата.
   */
  return function(input) {
    return new async.output.FilterCollector(opt_null);
  };
};




/**
 * Коллекционер игнорирующий результаты шагов сценария.
 *
 * Результатом накопления данного коллекционера является переданное в
 * конструктор значение.
 *
 * @constructor
 * @implements {async.output.ICollector}
 * @param {async.Input} input Входные данные выполнения шага.
 */
async.output.NopCollector = function(input) {

  /**
   * @type {async.Input}
   */
  this.__input = input;
};


/**
 * @override
 */
async.output.NopCollector.prototype.add = function(data) {};


/**
 * @override
 */
async.output.NopCollector.prototype.get = function() {
  return this.__input;
};



/**
 * Коллекционер игнорирующий результаты шагов сценария.
 *
 * Результатом накопления данного коллекционера является `null`.
 *
 * @constructor
 * @implements {async.output.ICollector}
 */
async.output.NullCollector = function() {};


/**
 * @override
 */
async.output.NullCollector.prototype.add = function(data) {};


/**
 * @override
 */
async.output.NullCollector.prototype.get = function() {
  return null;
};



/**
 * Коллекционер собирающий результаты в массив.
 *
 * @constructor
 * @implements {async.output.ICollector}
 */
async.output.ArrayCollector = function() {

  /**
   * @type {!Array.<*>}
   */
  this.__result = [];
};


/**
 * @override
 */
async.output.ArrayCollector.prototype.add = function(data) {
  this.__result.push(data);
};


/**
 * @override
 */
async.output.ArrayCollector.prototype.get = function() {
  return this.__result;
};



/**
 * Коллекционер сохраняющий только последний результат.
 *
 * @constructor
 * @implements {async.output.ICollector}
 */
async.output.OneCollector = function() {

  /**
   * @type {async.Output}
   */
  this.__one = null;
};


/**
 * @override
 */
async.output.OneCollector.prototype.add = function(data) {
  this.__one = data;
};


/**
 * @override
 */
async.output.OneCollector.prototype.get = function() {
  return this.__one;
};



/**
 * @constructor
 * @implements {async.output.ICollector}
 */
async.output.AndCollector = function() {

  /**
   * @type {boolean}
   */
  this.__result = true;
};


/**
 * @override
 */
async.output.AndCollector.prototype.add = function(data) {
  this.__result = this.__result && Boolean(data);
};


/**
 * @override
 */
async.output.AndCollector.prototype.get = function() {
  return this.__result;
};


/**
 * @param {...*} var_args Аргументы для вывода.
 * @return {!async.Step} Шаг вывода в консоль.
 */
async.console.info = function(var_args) {
  var args = Array.prototype.slice.call(arguments);

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function info(input, complete, cancel) {
    console.info.apply(console, args.concat(String(input)));
    complete(input);
  }

  return info;
};


/**
 * @param {...*} var_args Аргументы для вывода.
 * @return {!async.Step} Шаг вывода в консоль.
 */
async.console.warn = function(var_args) {
  var args = Array.prototype.slice.call(arguments);

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function warn(input, complete, cancel) {
    console.warn.apply(console, args.concat(String(input)));
    complete(input);
  }

  return warn;
};


/**
 * @param {...*} var_args Аргументы для вывода.
 * @return {!async.Step} Шаг вывода в консоль.
 */
async.console.error = function(var_args) {
  var args = Array.prototype.slice.call(arguments);

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function error(input, complete, cancel) {
    console.error.apply(console, args.concat(String(input)));
    complete(input);
  }

  return error;
};


/**
 * @param {...*} var_args Аргументы для вывода.
 * @return {!async.Step} Шаг вывода в консоль.
 */
async.console.log = function(var_args) {
  var args = Array.prototype.slice.call(arguments);

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function log(input, complete, cancel) {
    console.log.apply(console, args);
    complete(input);
  }

  return log;
};


/**
 * @param {...*} var_args Аргументы для вывода.
 * @return {!async.Step} Шаг вывода в консоль.
 */
async.console.expand = function(var_args) {
  var args = Array.prototype.slice.call(arguments);

  /**
   * @param {async.Input} input Входные данные.
   * @param {!async.CompleteHandler} complete Обработчик результата.
   * @param {!async.ErrorHandler} cancel Обработчик ошибки.
   */
  function log(input, complete, cancel) {
    console.log.apply(console, args.concat(input));
    complete(input);
  }

  return log;
};


/**
 * @namespace
 */
var ds = {};


/**
 * @namespace
 */
ds.queue = {};



/**
 * @interface
 */
ds.IDataItem = function() {};


/**
 * @return {*} Данные.
 */
ds.IDataItem.prototype.get = function() {};




/**
 * @interface
 */
ds.IDataSet = function() {};


/**
 * @param {(number|string)=} opt_type Тип итератора.
 * @return {!ds.IIterator} Итератор.
 */
ds.IDataSet.prototype.getIterator = function(opt_type) {};


/**
 * @param {!ds.IDataItem} item Элемент для удаления.
 * @return {!ds.IDataItem} Удаленный элемент.
 */
ds.IDataSet.prototype.remove = function(item) {};


/**
 *
 */
ds.IDataSet.prototype.destroy = function() {};



/**
 * @interface
 */
ds.IIterator = function() {};


/**
 * Имеется ли следующий элемент.
 *
 * @return {boolean} Результат проверки.
 */
ds.IIterator.prototype.hasNext = function() {};


/**
 * @param {!ds.IDataItem} item Элемент для проверки.
 * @return {boolean} Результат проверки.
 */
ds.IIterator.prototype.isNext = function(item) {};


/**
 * @return {ds.IDataItem} Следующий элемент.
 */
ds.IIterator.prototype.next = function() {};


/**
 *
 */
ds.IIterator.prototype.destroy = function() {};



/**
 * @constructor
 * @implements {ds.IDataItem}
 * @param {*} data Данные.
 */
ds.queue.QueueItem = function(data) {

  /**
   * @type {!ds.queue.QueueItem}
   */
  this.next = this;

  /**
   * @type {!ds.queue.QueueItem}
   */
  this.prev = this;

  /**
   * @type {*}
   */
  this.__data = data;
};


/**
 * @inheritDoc
 */
ds.queue.QueueItem.prototype.get = function() {
  return this.__data;
};



/**
 * @constructor
 * @implements {ds.IIterator}
 * @param {!ds.queue.Queue} queue Очередь.
 */
ds.queue.QueueIterator = function(queue) {

  /**
   * @type {!ds.queue.Queue}
   */
  this.__queue = queue;

  /**
   * @type {ds.queue.QueueItem}
   */
  this.__next = queue.getFirst();

  if (this.__next !== null) {
    this.__queue.addActiveIterator(this);
  }
};


/**
 * @inheritDoc
 */
ds.queue.QueueIterator.prototype.hasNext = function() {
  return this.__next !== null;
};


/**
 * @inheritDoc
 */
ds.queue.QueueIterator.prototype.isNext = function(item) {
  return this.__next === item;
};


/**
 * @inheritDoc
 */
ds.queue.QueueIterator.prototype.next = function() {
  var current = this.__next;

  if (this.__next !== null) {
    this.__next = this.__queue.getBefore(this.__next);
  } else {
    this.__queue.removeActiveIterator(this);
  }

  return current;
};


/**
 * @inheritDoc
 */
ds.queue.QueueIterator.prototype.destroy = function() {
  this.__queue.removeActiveIterator(this);
  this.__next = null;
};



/**
 * @constructor
 * @implements {ds.IDataSet}
 */
ds.queue.Queue = function() {

  /**
   * @type {number}
   */
  this.length = 0;

  /**
   * @type {!Array.<!ds.queue.QueueIterator>}
   */
  this.__activeIterators = [];

  /**
   * @type {!ds.queue.QueueItem}
   */
  this.__base = new ds.queue.QueueItem(null);
};


/**
 * @inheritDoc
 */
ds.queue.Queue.prototype.getIterator = function(opt_type) {
  return new ds.queue.QueueIterator(this);
};


/**
 * @inheritDoc
 */
ds.queue.Queue.prototype.destroy = function() {
  while (this.__base.prev !== this.__base) {
    this.remove(this.__base.prev);
  }
};


/**
 * @param {!ds.queue.QueueIterator} iterator Итератор.
 */
ds.queue.Queue.prototype.addActiveIterator = function(iterator) {
  this.__activeIterators.push(iterator);
};


/**
 * @param {!ds.queue.QueueIterator} iterator Итератор.
 */
ds.queue.Queue.prototype.removeActiveIterator = function(iterator) {
  var index = this.__activeIterators.indexOf(iterator);
  if (index !== -1) {
    this.__activeIterators.splice(iterator);
  }
};


/**
 * @return {ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.getFirst = function() {
  if (this.__base.prev !== this.__base) {
    return this.__base.prev;
  }

  return null;
};


/**
 * @return {ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.getLast = function() {
  if (this.__base.next !== this.__base) {
    return this.__base.next;
  }

  return null;
};


/**
 * @param {!ds.queue.QueueItem} target Элемент очереди.
 * @return {ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.getBefore = function(target) {
  if (target.prev !== this.__base) {
    return target.prev;
  }

  return null;
};


/**
 * @param {!ds.queue.QueueItem} target Элемент очереди.
 * @return {ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.getAfter = function(target) {
  if (target.next !== this.__base) {
    return target.next;
  }

  return null;
};


/**
 * @param {!ds.queue.QueueItem} item Элемент очереди.
 * @param {!ds.queue.QueueItem} target Элемент очереди.
 * @return {!ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.addBefore = function(item, target) {
  target.prev.next = item;
  item.prev = target.prev;

  target.prev = item;
  item.next = target;

  this.length += 1;

  return item;
};


/**
 * @param {!ds.queue.QueueItem} item Элемент очереди.
 * @param {!ds.queue.QueueItem} target Элемент очереди.
 * @return {!ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.addAfter = function(item, target) {
  target.next.prev = item;
  item.next = target.next;

  target.next = item;
  item.prev = target;

  this.length += 1;

  return item;
};


/**
 * @param {*} data Элемент очереди.
 * @return {!ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.push = function(data) {
  if (data instanceof ds.queue.QueueItem) {
    return this.addBefore(data, this.__base.next);
  }

  return this.addBefore(new ds.queue.QueueItem(data), this.__base.next);
};


/**
 * @param {!ds.queue.QueueItem|*} data Элемент очереди.
 * @return {!ds.queue.QueueItem} Элемент очереди.
 */
ds.queue.Queue.prototype.unshift = function(data) {
  if (data instanceof ds.queue.QueueItem) {
    return this.addAfter(data, this.__base.prev);
  }

  return this.addAfter(new ds.queue.QueueItem(data), this.__base.prev);
};


/**
 * @inheritDoc
 */
ds.queue.Queue.prototype.remove = function(item) {
  var i = 0,
      l = this.__activeIterators.length;

  while (i < l) {
    if (this.__activeIterators[i].isNext(item)) {
      this.__activeIterators[i].next();
    }

    i += 1;
  }

  item.next.prev = item.prev;
  item.prev.next = item.next;

  item.next = item;
  item.prev = item;

  this.length -= 1;

  return item;
};


/**
 * @return {*} Элемент очереди.
 */
ds.queue.Queue.prototype.shift = function() {
  if (this.__base.prev !== this.__base) {
    return this.remove(this.__base.prev).get();
  }

  return null;
};


/**
 * @return {*} Элемент очереди.
 */
ds.queue.Queue.prototype.pop = function() {
  if (this.__base.prev !== this.__base) {
    return this.remove(this.__base.next).get();
  }

  return null;
};


/**
 * @return {*} Элемент очереди.
 */
ds.queue.Queue.prototype.head = function() {
  return this.__base.prev.get();
};


/**
 * @return {*} Элемент очереди.
 */
ds.queue.Queue.prototype.tail = function() {
  return this.__base.next.get();
};


/**
 * @param {function(*)} callback Обработчик элемента очереди.
 */
ds.queue.Queue.prototype.map = function(callback) {
  var iterator = this.getIterator();

  while (iterator.hasNext()) {
    callback(iterator.next().get());
  }

  iterator.destroy();
};


/**
 * @namespace
 */
var thrift = {};


/**
 * @namespace
 */
thrift.protocol = {};


/**
 * @namespace
 */
thrift.definition = {};


/**
 * @namespace
 */
thrift.io = {};


/**
 * @namespace
 */
thrift.io.http = {};


/**
 * @namespace
 */
thrift.io.tcp = {};


/**
 * @typedef {*}
 */
thrift.Value;


/**
 * @typedef {?function(number,
 *    !thrift.protocol.IProtocol):thrift.IPacketHandler}
 */
thrift.HandlerBuilder;


/**
 * @param {number} type
 * @param {!thrift.protocol.IProtocol} protocol
 * @return {thrift.IPacketHandler}
 */
thrift.handlerBuilder = function(type, protocol) {
  if (type >= thrift.definition.Type.BOOL &&
      type < thrift.definition.Type.STRUCT) {
    return new thrift.SimpleHandler(type, protocol);
  }

  if (type === thrift.definition.Type.LIST ||
      type === thrift.definition.Type.SET) {
    return thrift.protocol.ARRAY_HANDLER(type, protocol);
  }

  if (type === thrift.definition.Type.MAP) {
    return thrift.protocol.MAP_HANDLER(type, protocol);
  }

  if (type === thrift.definition.Type.STRUCT) {
    return thrift.protocol.STRUCTURE_HANDLER(type, protocol);
  }

  if (type === thrift.definition.Type.STOP) {
    return new thrift.SimpleHandler(type, protocol);
  }

  return null;
};


/**
 * @param {!thrift.protocol.IProtocol} protocol
 * @param {number} id
 * @param {string} name
 * @param {!Array.<thrift.Value>} args
 * @return {!Buffer}
 */
thrift.encodeCall = function(protocol, id, name, args) {
  var idl = protocol.getIdl(),
      collector = new thrift.protocol.ChunkCollector();

  var method = idl.getMethodDefinition(name);
  if (method !== null) {
    protocol.writeMessageHeader(collector, name,
        thrift.definition.MessageType.CALL, id);

    for (var i = 0; i < args.length; i += 1) {
      var param = method.getParameter(i + 1);
      if (param !== null) {
        var type = param.getFullType();

        protocol.writeFieldHeader(collector, type.getType(), i + 1);
        thrift.serializeValue(collector, args[i], type, protocol);
      }
    }
    protocol.writeFieldStop(collector);
  } else {
    console.warn('Can\'t call method:', name, '[thrift.encodeCall]');
  }

  return collector.getTotalBytes();
};


/**
 * @param {!thrift.protocol.IProtocol} protocol
 * @param {number} id
 * @param {string} name
 * @param {thrift.Value} data
 * @return {!Buffer}
 */
thrift.encodeReply = function(protocol, id, name, data) {
  var idl = protocol.getIdl(),
      collector = new thrift.protocol.ChunkCollector();

  var method = idl.getMethodDefinition(name);
  if (method !== null) {
    var type = method.getReturnType();

    protocol.writeMessageHeader(collector, name,
        thrift.definition.MessageType.REPLY, id);

    protocol.writeFieldHeader(collector, type.getType(), 0);
    thrift.serializeValue(collector, data, type, protocol);
    protocol.writeFieldStop(collector);
  } else {
    console.warn('Can\'t reply to method:', name, '[thrift.encodeReply]');
  }
  return collector.getTotalBytes();
};


/**
 * @param {!thrift.protocol.IProtocol} protocol
 * @param {!number} id
 * @param {!string} name
 * @param {!String} message
 * @param {number=} opt_code
 * @return {!Buffer}
 */
thrift.encodeException =
    function(protocol, id, name, message, opt_code) {
  var collector = new thrift.protocol.ChunkCollector();

  protocol.writeMessageHeader(collector, name,
      thrift.definition.MessageType.EXCEPTION, id);

  protocol.writeFieldHeader(collector, thrift.definition.Type.STRING, 1);

  thrift.serializeValue(collector, message,
      new thrift.definition.FullType(thrift.definition.Type.STRING), protocol);

  if (opt_code !== undefined) {
    protocol.writeFieldHeader(collector, thrift.definition.Type.I16, 2);
    thrift.serializeValue(collector, opt_code,
        new thrift.definition.FullType(thrift.definition.Type.I16), protocol);
  }
  protocol.writeFieldStop(collector);

  return collector.getTotalBytes();
};


/**
 * @param {thrift.Value} field
 * @param {!thrift.definition.FullType} fullType
 * @param {!thrift.ISchema} idl
 * @return {thrift.Value}
 */
thrift.convertNestedStructure = function(field, fullType, idl) {
  var resultField = field;

  if (fullType.getType() === thrift.definition.Type.STRUCT) {
    if (field instanceof Object) {
      resultField =
          thrift.convertStructure(fullType.getStructType(), field, idl);
    }
  }

  if (fullType.getType() === thrift.definition.Type.MAP ||
      fullType.getType() === thrift.definition.Type.LIST ||
      fullType.getType() === thrift.definition.Type.SET) {

    var valueType = fullType.getValueType();
    if (valueType.getType() === thrift.definition.Type.STRUCT) {
      for (var key in field) {
        resultField[key] = thrift.convertStructure(
            valueType.getStructType(), field[key], idl);
      }
    }
  }

  return resultField;
};


/**
 * @param {string} type structure class name.
 * @param {!Object} structure thriftStructure
 * @param {!thrift.ISchema} idl
 * @return {!Object}
 */
thrift.convertStructure = function(type, structure, idl) {
  var structureDefinition = idl.getStructureDefinition(type);
  var args = {};
  var result = {};

  if (structureDefinition !== null) {
    for (var id in structure) {
      var field = structure[id];
      var fieldFullType = structureDefinition.getTypeById(id);
      if (fieldFullType !== null) {
        field = thrift.convertNestedStructure(field, fieldFullType, idl);
        args[id] = field;
      } else {
        console.warn('Unknown field with id: ' + id + ' in Structure: ' + type);
      }
    }
    result = idl.createStructure(type, args);
  } else {
    console.warn('Unknown structure: ' + type + ' in Idl');
  }

  return result;
};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {!thrift.Value} value
 * @param {!thrift.definition.FullType} fullType
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.serializeValue = function(collector, value, fullType, protocol) {
  var type = fullType.getType();
  if ((typeof value === 'string') &&
      type === thrift.definition.Type.STRING) {
    protocol.writeString(collector, value);
  } else if (typeof value === 'boolean' &&
      type === thrift.definition.Type.BOOL) {
    protocol.writeBool(collector, value);
  } else if (typeof value === 'number') {
    if (type === thrift.definition.Type.BYTE) {
      protocol.writeByte(collector, value);
    } else if (type === thrift.definition.Type.I16) {
      protocol.writeI16(collector, value);
    } else if (type === thrift.definition.Type.I32) {
      protocol.writeI32(collector, value);
    } else if (type === thrift.definition.Type.I64) {
      protocol.writeI64(collector, value);
    } else if (type === thrift.definition.Type.DOUBLE) {
      protocol.writeDouble(collector, value);
    }
  } else if (value instanceof thrift.protocol.Int64) {
    protocol.writeI64(collector, value);
  } else if (value instanceof Object) {
    if (type === thrift.definition.Type.MAP) {
      protocol.serializeMap(collector,
          value, fullType.getKeyType(), fullType.getValueType());
    } else if (type === thrift.definition.Type.SET ||
        type === thrift.definition.Type.LIST) {
      protocol.serializeArray(collector, value, fullType.getValueType());
    } else if (type === thrift.definition.Type.STRUCT) {
      protocol.serializeStructure(collector, value, fullType.getStructType());
    }
  } else {
    console.warn('Unknown value type: ' + type + ' [thrift.serializeValue]');
  }
};




/**
 * @interface
 */
thrift.IPacketHandler = function() {};


/**
 * Shifts cursor and returns is's new position.
 *
 * @param {!thrift.Cursor} cursor object.
 * @param {!Buffer} chunk Data packet.
 * @return {boolean} Flag of packet handling.
 */
thrift.IPacketHandler.prototype.process = function(cursor, chunk) {};


/**
 * @return {thrift.Value}
 */
thrift.IPacketHandler.prototype.get = function() {};



/**
 * @interface
 */
thrift.IValueKeeper = function() {};


/**
 * @return {boolean}
 */
thrift.IValueKeeper.prototype.isComplete = function() {};


/**
 * @param {thrift.Value} value
 */
thrift.IValueKeeper.prototype.applyData = function(value) {};


/**
 * @return {thrift.Value} value
 */
thrift.IValueKeeper.prototype.get = function() {};


/**
 * @return {number} type
 */
thrift.IValueKeeper.prototype.getType = function() {};


/**
 * @param {!thrift.Cursor} cursor object.
 * @param {!Buffer} chunk Data packet.
 */
thrift.IValueKeeper.prototype.processHeader = function(cursor, chunk) {};


/**
 * @return {boolean} Flag of packet handling.
 */
thrift.IValueKeeper.prototype.isHeaderComplete = function() {};




/**
 * @interface
 */
thrift.ISchema = function() {};


/**
 * @param {string} type
 * @param {!Object} args
 * @return {!Object}
 */
thrift.ISchema.prototype.createStructure = function(type, args) {};


/**
 * @param {string} type
 * @return {thrift.definition.Structure}
 */
thrift.ISchema.prototype.getStructureDefinition = function(type) {};


/**
 * @param {string} name
 * @return {thrift.definition.Method}
 */
thrift.ISchema.prototype.getMethodDefinition = function(name) {};



/**
 * Global cursor.
 * @constructor
 */
thrift.Cursor = function() {

  /**
   * @type {number}.
   */
  this.__position = 0;

  /**
   * @type {boolean}.
   */
  this.__isParsed = true;
};


/**
 * @return {number} current cursor position.
 */
thrift.Cursor.prototype.getPosition = function() {
  return this.__position;
};


/**
 * @param {number} value increment current position on value.
 */
thrift.Cursor.prototype.incrPosition = function(value) {
  this.__position += value;
};


/**
 * @return {boolean}
 */
thrift.Cursor.prototype.isParsed = function() {
  return this.__isParsed;
};


/**
 * set this.__isParsed in false, flag - finish data.
 */
thrift.Cursor.prototype.breakParsing = function() {
  this.__isParsed = false;
};






/**
 * @constructor
 *
 * @param {string} name
 * @param {number} type
 * @param {number} seqid
 * @param {thrift.Value} value
 */
thrift.Message = function(name, type, seqid, value) {

  /**
   * @type {string}
   */
  this.__name = name;

  /**
   * @type {number}
   */
  this.__type = type;

  /**
   * @type {number}
   */
  this.__seqid = seqid;

  /**
   * @type {thrift.Value}
   */
  this.__value = value;
};


/**
 * @return {thrift.Value}
 */
thrift.Message.prototype.getValue = function() {
  return this.__value;
};


/**
 * @return {number}
 */
thrift.Message.prototype.getType = function() {
  return this.__type;
};


/**
 * @return {string}
 */
thrift.Message.prototype.getName = function() {
  return this.__name;
};


/**
 * @return {number}
 */
thrift.Message.prototype.getId = function() {
  return this.__seqid;
};


/**
 * @return {boolean}
 */
thrift.Message.prototype.isException = function() {
  return this.__type === thrift.definition.MessageType.EXCEPTION;
};



/**
 * @constructor
 * @param {number} type
 * @param {number} id
 * @param {thrift.Value} value
 */
thrift.Field = function(type, id, value) {

  /**
   * @type {thrift.Value}
   */
  this.__value = value;

  /**
   * @type {number}
   */
  this.__type = type;

  /**
   * @type {number}
   */
  this.__id = id;
};


/**
 * @return {thrift.Value}
 */
thrift.Field.prototype.getValue = function() {
  return this.__value;
};


/**
 * @return {number}
 */
thrift.Field.prototype.getType = function() {
  return this.__type;
};


/**
 * @return {number}
 */
thrift.Field.prototype.getId = function() {
  return this.__id;
};



/**
 * @constructor
 * @param {!thrift.protocol.IProtocol}  protocol
 */
thrift.Parser = function(protocol) {

  /**
   * @type {!thrift.ISchema} idl
   */
  this.__idl = protocol.getIdl();

  /**
   * @type {!thrift.protocol.IProtocol} protocol
   */
  this.__protocol = protocol;

  /**
   * @type {!Buffer}
   */
  this.__readBuffer = new Buffer(0);

  /**
   * @type {thrift.IPacketHandler}
   */
  this.__handler = null;
};


/**
 * @param {!Buffer} chunk
 * @return {!Array.<!thrift.Message>}
 */
thrift.Parser.prototype.process = function(chunk) {
  var cursor = new thrift.Cursor();
  var result = [];

  this.__readBuffer = this.__readBuffer.length > 0 ?
      Buffer.concat([this.__readBuffer, chunk]) : chunk;

  while (this.__readBuffer.length > 0 &&
      cursor.getPosition() < chunk.length && cursor.isParsed()) {

    if (this.__handler === null) {
      this.__handler = thrift.protocol.MESSAGE_HANDLER(this.__protocol);
    }

    if (this.__handler.process(cursor, this.__readBuffer)) {
      var message = this.__handler.get();
      if (message instanceof thrift.Message) {
        result.push(message);
      }

      this.__handler = null;
    }
  }

  this.__readBuffer = this.__readBuffer.slice(cursor.getPosition());

  return result;
};




/**
 * @constructor
 * @param {!thrift.io.IClientTransport} transport
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.io.Client = function(transport, protocol) {

  /**
   * @type {!thrift.protocol.IProtocol}
   */
  this.__protocol = protocol;

  /**
   * @type {!thrift.Parser}
   */
  this.__parser = new thrift.Parser(protocol);

  /**
   * @type {!thrift.io.IClientTransport}
   */
  this.__transport = transport;
  this.__transport.init(this);

  /**
   * @type {!Object.<number, !async.Request>}
   */
  this.__requests = {};

  /**
   * @type {number}
   */
  this.__index = 0;
};


/**
 * @param {!Buffer} payload Объект ответа.
 */
thrift.io.Client.prototype.process = function(payload) {
  var messages = this.__parser.process(payload);

  for (var i = 0; i < messages.length; i += 1) {
    var message = messages[i];
    var id = message.getId();

    var request = this.__requests[id];
    if (request !== undefined) {
      delete this.__requests[id];

      if (message.isException()) {
        request.cancel(message.getValue());
      } else {
        request.complete(message.getValue());
      }

    }
  }
};


/**
 * @param {string} name
 * @param {!Array.<thrift.Value>} args
 * @param {!async.CompleteHandler} complete
 * @param {!async.ErrorHandler} cancel
 */
thrift.io.Client.prototype.request = function(name, args, complete, cancel) {
  this.__requests[this.__index += 1] = new async.Request(complete, cancel);

  var bytes = thrift.encodeCall(this.__protocol, this.__index, name, args);
  this.__transport.write(bytes);
};


/**
 *
 */
thrift.io.Client.prototype.destroy = function() {
  this.__transport.destroy();
  this.__requests = {};
};



/**
 * @constructor
 * @implements {thrift.io.IClientTransport}
 * @param {number} port Connection port.
 * @param {string=} opt_host Хост Connection host.
 */
thrift.io.tcp.Client = function(port, opt_host) {
  var self = this;

  function connect() {
    self.__connect();
  }

  /**
   * @type {net.Socket}
   */
  this.__socket = null;

  /**
   * @type {number}
   */
  this.__port = port;

  /**
   * @type {string}
   */
  this.__host = opt_host || '0.0.0.0';

  /**
   * @type {boolean}
   */
  this.__isConnected = false;

  /**
   * @type {!Array.<!Buffer>}
   */
  this.__writeQueue = [];

  /**
   * @param {!Buffer} data
   */
  this.__handleData = function(data) {};

  /**
   *
   */
  this.__handleOpen = function() {
    self.__isConnected = true;
    self.__flush();
  };

  /**
   *
   */
  this.__handleClose = function() {
    self.__isConnected = false;
    self.__close();

    setTimeout(connect, thrift.io.tcp.Client.RECONNECT_TIMEOUT);
  };
};


/**
 * @type {number}
 */
thrift.io.tcp.Client.RECONNECT_TIMEOUT = 1000;


/**
 * @inheritDoc
 */
thrift.io.tcp.Client.prototype.init = function(client) {
  /**
   * @param {!Buffer} data
   */
  this.__handleData = function(data) {
    client.process(data);
  };

  this.__connect();
};


/**
 * @inheritDoc
 */
thrift.io.tcp.Client.prototype.write = function(bytes) {
  this.__writeQueue.push(bytes);
  this.__flush();
};


/**
 * @inheritDoc
 */
thrift.io.tcp.Client.prototype.destroy = function() {
  this.__close();
  this.__writeQueue.length = 0;
};


/**
 *
 */
thrift.io.tcp.Client.prototype.__flush = function() {
  if (this.__socket !== null &&
      this.__isConnected) {

    while (this.__writeQueue.length > 0) {
      this.__socket.write(this.__writeQueue.shift());
    }
  }
};


/**
 *
 */
thrift.io.tcp.Client.prototype.__connect = function() {
  this.__socket = new net.Socket();
  this.__socket.addListener('connect', this.__handleOpen);
  this.__socket.addListener('close', this.__handleClose);
  this.__socket.addListener('data', this.__handleData);
  this.__socket.addListener('error', console.error);
  this.__socket.connect(this.__port, this.__host);
};


/**
 *
 */
thrift.io.tcp.Client.prototype.__close = function() {
  if (this.__socket !== null) {
    this.__socket.removeAllListeners();
    this.__socket.end();
    this.__socket = null;
  }
};



/**
 * @interface
 */
thrift.io.IClientTransport = function() {};


/**
 * @param {!Buffer} bytes
 */
thrift.io.IClientTransport.prototype.write = function(bytes) {};


/**
 * @param {!thrift.io.Client} client
 */
thrift.io.IClientTransport.prototype.init = function(client) {};


/**
 *
 */
thrift.io.IClientTransport.prototype.destroy = function() {};



/**
 * @constructor
 * @implements {thrift.IPacketHandler}
 * @param {number} type
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.SimpleHandler = function(type, protocol) {

  /**
   * @type {number}
   */
  this.__type = type;

  /**
   * @type {!thrift.protocol.IProtocol}
   */
  this.__protocol = protocol;

  /**
   * @type {thrift.Value}
   */
  this.__output = null;
};


/**
 * @inheritDoc
 */
thrift.SimpleHandler.prototype.get = function() {
  return this.__output;
};


/**
 * @inheritDoc
 */
thrift.SimpleHandler.prototype.process = function(cursor, chunk) {
  if (this.__type === thrift.definition.Type.STRING) {
    this.__output = this.__protocol.readString(cursor, chunk);
  } else if (this.__type === thrift.definition.Type.BOOL) {
    this.__output = this.__protocol.readBool(cursor, chunk);
  } else if (this.__type === thrift.definition.Type.BYTE) {
    this.__output = this.__protocol.readByte(cursor, chunk);
  } else if (this.__type === thrift.definition.Type.I16) {
    this.__output = this.__protocol.readI16(cursor, chunk);
  } else if (this.__type === thrift.definition.Type.I32) {
    this.__output = this.__protocol.readI32(cursor, chunk);
  } else if (this.__type === thrift.definition.Type.I64) {
    this.__output = this.__protocol.readI64(cursor, chunk);
  } else if (this.__type === thrift.definition.Type.DOUBLE) {
    this.__output = this.__protocol.readDouble(cursor, chunk);
  }

  return cursor.isParsed();
};



/**
 *
 * @constructor
 * @implements {thrift.IPacketHandler}
 * @param {!thrift.protocol.IProtocol} protocol
 * @param {!thrift.HandlerBuilder} valueHandlerBuilder
 * @param {!thrift.IValueKeeper} valueKeeper
 */
thrift.IncludedHandler = function(protocol, valueHandlerBuilder,
                                  valueKeeper) {

  /**
   * @type {!thrift.protocol.IProtocol}
   */
  this.__protocol = protocol;

  /**
   * @type {thrift.IPacketHandler}
   */
  this.__valueParser = null;

  /**
   * @type {thrift.IValueKeeper}
   */
  this.__valueKeeper = valueKeeper;

  /**
   * @type {!thrift.HandlerBuilder}
   */
  this.__valueHandlerBuilder = valueHandlerBuilder;
};


/**
 * @inheritDoc
 */
thrift.IncludedHandler.prototype.process = function(cursor, chunk) {
  if (!this.__valueKeeper.isHeaderComplete()) {
    this.__valueKeeper.processHeader(cursor, chunk);
  }

  if (this.__valueKeeper.isHeaderComplete()) {
    this.__processBody(cursor, chunk);
  }

  return cursor.isParsed();
};


/**
 * @param {!thrift.Cursor} cursor
 * @param {!Buffer} chunk
 */
thrift.IncludedHandler.prototype.__processBody = function(cursor, chunk) {
  while (cursor.isParsed() && !this.__valueKeeper.isComplete()) {
    if (this.__valueParser === null) {
      this.__valueParser = this.__valueHandlerBuilder(
          this.__valueKeeper.getType(), this.__protocol);

      if (this.__valueParser === null) {
        break;
      }
    }

    if (this.__valueParser !== null) {
      if (this.__valueParser.process(cursor, chunk)) {
        this.__valueKeeper.applyData(this.__valueParser.get());
        this.__valueParser = null;
      }
    }
  }
};


/**
 * @inheritDoc
 */
thrift.IncludedHandler.prototype.get = function() {
  return this.__valueKeeper.get();
};


/**
 * TODO: remove
 *
 * @enum {number}
 */
thrift.definition.ExceptionType = {
  'UNKNOWN': 0,
  'UNKNOWN_METHOD': 1,
  'INVALID_MESSAGE_TYPE': 2,
  'WRONG_METHOD_NAME': 3,
  'BAD_SEQUENCE_ID': 4,
  'MISSING_RESULT': 5,
  'INTERNAL_ERROR': 6,
  'PROTOCOL_ERROR': 7,
  'INVALID_TRANSFORM': 8,
  'INVALID_PROTOCOL': 9,
  'UNSUPPORTED_CLIENT_TYPE': 10
};


/**
 * @enum {number}
 */
thrift.definition.MessageType = {
  CALL: 1,
  REPLY: 2,
  EXCEPTION: 3
};


/**
 * @enum {number}
 */
thrift.definition.Type = {
  'NOP': -1,
  'STOP': 0,
  'VOID': 1,
  'BOOL': 2,
  'BYTE': 3,
  'I08': 3,
  'DOUBLE': 4,
  'I16': 6,
  'I32': 8,
  'I64': 10,
  'STRING': 11,
  'UTF7': 11,
  'STRUCT': 12,
  'MAP': 13,
  'SET': 14,
  'LIST': 15,
  'UTF8': 16,
  'UTF16': 17
};



/**
 * Wrapper for types;
 *
 * @constructor
 * @param {thrift.definition.Type|string} type
 * @param {!thrift.definition.FullType|string|thrift.definition.Type=} opt_vType
 * @param {!thrift.definition.FullType|string|thrift.definition.Type=} opt_kType
 */
thrift.definition.FullType = function(type, opt_vType, opt_kType) {

  /**
   * @type {number}
   */
  this.__type = (typeof type === 'string') ?
      thrift.definition.Type.STRUCT : type;

  /**
   * @type {thrift.definition.FullType}
   */
  this.__kType = null;

  /**
   * @type {thrift.definition.FullType}
   */
  this.__vType = null;

  /**
   * @type {string}
   */
  this.__structType = (typeof type === 'string') ? type : '';


  if (opt_vType !== undefined) {
    this.__vType = (opt_vType instanceof thrift.definition.FullType) ?
        opt_vType : new thrift.definition.FullType(opt_vType ||
            thrift.definition.Type.STRING);
  }

  if (opt_kType !== undefined) {
    this.__kType = (opt_kType instanceof thrift.definition.FullType) ?
        opt_kType : new thrift.definition.FullType(opt_kType ||
            thrift.definition.Type.STRING);
  }
};


/**
 * @type {!thrift.definition.FullType}
 */
thrift.definition.FullType.NULL =
    new thrift.definition.FullType(thrift.definition.Type.NOP);


/**
 * @return {number}
 */
thrift.definition.FullType.prototype.getType = function() {
  return this.__type;
};


/**
 * @return {!thrift.definition.FullType}
 */
thrift.definition.FullType.prototype.getKeyType = function() {
  return this.__kType || thrift.definition.FullType.NULL;
};


/**
 * @return {!thrift.definition.FullType}
 */
thrift.definition.FullType.prototype.getValueType = function() {
  return this.__vType || thrift.definition.FullType.NULL;
};


/**
 * @return {string}
 */
thrift.definition.FullType.prototype.getStructType = function() {
  return this.__structType;
};




/**
 * @constructor
 * @param {string} name
 * @param {number} id
 * @param {thrift.definition.Type|string} type
 * @param {!thrift.definition.FullType|thrift.definition.Type|string=} opt_vType
 * @param {!thrift.definition.FullType|thrift.definition.Type|string=} opt_kType
 */
thrift.definition.Field = function(name, id, type, opt_vType, opt_kType) {

  /**
   * @type {!string}
   */
  this.__name = name;

  /**
   * @type {number}
   */
  this.__id = id;

  /**
   * @type {!thrift.definition.FullType}
   */
  this.__fullType = new thrift.definition.FullType(type, opt_vType, opt_kType);
};


/**
 * @return {!string}
 */
thrift.definition.Field.prototype.getName = function() {
  return this.__name;
};


/**
 * @return {number}
 */
thrift.definition.Field.prototype.getId = function() {
  return this.__id;
};


/**
 * @return {!thrift.definition.FullType}
 */
thrift.definition.Field.prototype.getFullType = function() {
  return this.__fullType;
};


/**
 * @return {number}
 */
thrift.definition.Field.prototype.getType = function() {
  return this.__fullType.getType();
};



/**
 * @constructor
 *
 * @param {!Object.<number, !thrift.definition.Field>} parameters
 * @param {!thrift.definition.FullType=} opt_returnType
 */
thrift.definition.Method = function(parameters, opt_returnType) {

  /**
   * @type {!Object.<(number|string), !thrift.definition.Field>}
   */
  this.__parameters = parameters;

  /**
   * @type {!thrift.definition.FullType}
   */
  this.__returnType = opt_returnType ? opt_returnType :
      new thrift.definition.FullType(thrift.definition.Type.VOID);
};


/**
 * @param {number|string} id
 * @return {thrift.definition.Field}
 */
thrift.definition.Method.prototype.getParameter = function(id) {
  return this.__parameters[id] || null;
};


/**
 * @return {!thrift.definition.FullType}
 */
thrift.definition.Method.prototype.getReturnType = function() {
  return this.__returnType;
};



/**
 * @constructor
 *
 * @param {!Object.<string, !thrift.definition.Field>} fields
 */
thrift.definition.Structure = function(fields) {

  /**
   * @type {!Object.<string, !thrift.definition.Field>}
   */
  this.__fieldsByName = fields;

  /**
   * @type {Object.<string, !thrift.definition.Field>}
   */
  this.__fieldsById = {};

  for (var i in fields) {
    this.__fieldsById[fields[i].getId()] = fields[i];
  }
};


/**
 * @param {string} id
 * @return {thrift.definition.FullType}
 */
thrift.definition.Structure.prototype.getTypeById = function(id) {
  var field = this.__fieldsById[id];
  if (field !== undefined) {
    return field.getFullType();
  } else {
    console.warn('Unknown field id: ' + id +
        '[thrift.definition.Structure.prototype.getTypeById]');
  }

  return null;
};


/**
 * @param {string} name
 * @return {thrift.definition.FullType}
 */
thrift.definition.Structure.prototype.getTypeByName = function(name) {
  var field = this.__fieldsByName[name];
  if (field !== undefined) {
    return field.getFullType();
  } else {
    console.warn('Unknown field name: ' + name +
        '[thrift.definition.Structure.prototype.getTypeById]');
  }

  return null;
};


/**
 * @param {string} name
 * @return {number}
 */
thrift.definition.Structure.prototype.getIdByName = function(name) {
  if (this.__fieldsByName[name] !== undefined) {
    return this.__fieldsByName[name].getId();
  } else {
    console.warn('Unknown field name: ' + name +
        '[thrift.definition.Structure.prototype.getIdByName]');
  }

  return -1;
};



/**
 * @constructor
 * @implements {thrift.protocol.IProtocol}
 * @param {!thrift.ISchema} idl
 */
thrift.protocol.Binary = function(idl) {

  /**
   * @type {!thrift.ISchema}
   */
  this.__idl = idl;
};


/**
 * @type {number} 0x80010000
 */
thrift.protocol.Binary.prototype.VERSION = -2147418112;


/**
 * @type {number} -65536
 */
thrift.protocol.Binary.prototype.VERSION_MASK = 0xffff0000;


/**
 * @type {number}
 */
thrift.protocol.Binary.prototype.TYPE_MASK = 0x000000ff;


/**
 * @return {!thrift.ISchema}
 */
thrift.protocol.Binary.prototype.getIdl = function() {
  return this.__idl;
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeMessageHeader =
    function(collector, methodName, type, seqid) {
  this.writeI32(collector, this.VERSION | type);
  this.writeString(collector, methodName);
  this.writeI32(collector, seqid);
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.serializeStructure =
    function(collector, struct, type) {
  var structureInfo = this.__idl.getStructureDefinition(type);

  for (var field in struct) {
    if (struct.hasOwnProperty(field) && struct[field] !== undefined) {
      var typeInfo = structureInfo.getTypeByName(field);
      var id = structureInfo.getIdByName(field);

      this.writeFieldHeader(collector, typeInfo.getType(), id);
      thrift.serializeValue(collector, struct[field], typeInfo, this);
    }
  }

  this.writeFieldStop(collector);
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.serializeMap =
    function(collector, map, keyInfo, valInfo) {

  var size = Object.keys(map).length;

  this.writeMapHeader(collector, keyInfo.getType(), valInfo.getType(), size);
  for (var key in map) {
    if (map.hasOwnProperty(key)) {
      thrift.serializeValue(collector, key, keyInfo, this);
      thrift.serializeValue(collector, map[key], valInfo, this);
    }
  }
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.serializeArray =
    function(collector, array, fullValueType) {

  this.writeListHeader(collector, fullValueType.getType(), array.length);

  for (var i = 0; i < array.length; i++) {
    if (array[i] !== undefined) {
      thrift.serializeValue(collector, array[i], fullValueType, this);
    }
  }
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeFieldHeader =
    function(collector, type, id) {
  this.writeByte(collector, type);
  this.writeI16(collector, id);
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeFieldStop = function(collector) {
  this.writeByte(collector, 0);
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeMapHeader =
    function(collector, ktype, vtype, size) {
  this.writeByte(collector, ktype);
  this.writeByte(collector, vtype);
  this.writeI32(collector, size);
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeListHeader =
    function(collector, etype, size) {
  this.writeByte(collector, etype);
  this.writeI32(collector, size);
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeSetHeader =
    function(collector, etype, size) {
  this.writeByte(collector, etype);
  this.writeI32(collector, size);
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeBool = function(collector, bool) {
  bool ? this.writeByte(collector, 1) : this.writeByte(collector, 0);
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeByte = function(collector, value) {
  collector.push(new Buffer(String.fromCharCode(value)));
  //collector.push(new Buffer([value]));
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeI16 = function(collector, value) {
  var output = new Buffer(2);
  output[1] = value & 0xff;
  value >>= 8;
  output[0] = value & 0xff;

  collector.push(output);
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeI32 = function(collector, value) {
  var output = new Buffer(4);
  output[3] = value & 0xff;
  value >>= 8;
  output[2] = value & 0xff;
  value >>= 8;
  output[1] = value & 0xff;
  value >>= 8;
  output[0] = value & 0xff;

  collector.push(output);
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeI64 = function(collector, value) {
  if (typeof value === 'number') {
    value = new thrift.protocol.Int64(value);
  }

  collector.push(value.getBuffer());
};


/**
 *
 *
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeDouble = function(collector, double) {
  var value = new Buffer(8);
  var mant = 0;
  var exp = Math.floor(Math.log(double) / Math.LN2);
  var c = Math.pow(2, -exp);
  double = Math.abs(double);

  value[0] = double < 0 ? 0x80 : 0x00;

  if (double * c < 1) {
    exp--;
    c *= 2;
  }

  if (exp + 1023 >= 2047) {
    mant = 0;
    exp = 2047;
  } else if (exp + 1023 >= 1) {
    mant = (double * c - 1) * Math.pow(2, 52);
    exp += 1023;
  } else {
    mant = (double * Math.pow(2, 1022)) * Math.pow(2, 52);
    exp = 0;
  }

  value[1] = (exp << 4) & 0xf0;
  value[0] |= (exp >> 4) & 0x7f;

  value[7] = mant & 0xff;
  mant >>= 8;
  value[6] = mant & 0xff;
  mant >>= 8;
  value[5] = mant & 0xff;
  mant >>= 8;
  value[4] = mant & 0xff;
  mant >>= 8;
  value[3] = mant & 0xff;
  mant >>= 8;
  value[2] = mant & 0xff;
  mant >>= 8;
  value[1] |= mant & 0x0f;

  collector.push(value);
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.writeString = function(collector, value) {
  this.writeI32(collector, Buffer.byteLength(value));
  collector.push(new Buffer(value));
};


/**
 * @inheritDoc
 */

thrift.protocol.Binary.prototype.readBool = function(cursor, chunk) {
  return this.readByte(cursor, chunk) ? true : false;
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.readByte = function(cursor, chunk) {
  var value = 0;
  if (cursor.getPosition() < chunk.length) {
    value = chunk[cursor.getPosition()];
    cursor.incrPosition(1);
  } else {
    cursor.breakParsing();
  }

  return value;
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.readI16 = function(cursor, chunk) {
  var value = 0;
  if ((cursor.getPosition() + 1) < chunk.length) {
    value = chunk[cursor.getPosition() + 1];
    value += chunk[cursor.getPosition()] << 8;

    if (chunk[cursor.getPosition()] & 128) {
      value -= Math.pow(2, 16);
    }

    cursor.incrPosition(2);
  } else {
    cursor.breakParsing();
  }
  return value;
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.readI32 = function(cursor, chunk) {
  var value = 0;
  if ((cursor.getPosition() + 3) < chunk.length) {

    value = chunk[cursor.getPosition() + 3];
    value += chunk[cursor.getPosition() + 2] << 8;
    value += chunk[cursor.getPosition() + 1] << 16;
    value += chunk[cursor.getPosition()] << 24;

    if (chunk[cursor.getPosition()] & 0x80) {
      value -= Math.pow(2, 32);
    }

    cursor.incrPosition(4);
  } else {
    cursor.breakParsing();
  }
  return value;
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.readI64 = function(cursor, chunk) {
  var value = null;
  if ((cursor.getPosition() + 7) < chunk.length) {
    value = new thrift.protocol.Int64(
        chunk.slice(cursor.getPosition(), cursor.getPosition() + 8));
    cursor.incrPosition(8);
  } else {
    cursor.breakParsing();
  }

  return value;
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.readDouble = function(cursor, chunk) {
  if ((cursor.getPosition() + 7) < chunk.length) {

    var signed = chunk[cursor.getPosition()] & 0x80;
    var e = (chunk[cursor.getPosition() + 1] & 0xF0) >> 4;
    e += (chunk[cursor.getPosition()] & 0x7F) << 4;

    var m = chunk[cursor.getPosition() + 7];
    m += chunk[cursor.getPosition() + 6] << 8;
    m += chunk[cursor.getPosition() + 5] << 16;
    m += chunk[cursor.getPosition() + 4] * Math.pow(2, 24);
    m += chunk[cursor.getPosition() + 3] * Math.pow(2, 32);
    m += chunk[cursor.getPosition() + 2] * Math.pow(2, 40);
    m += (chunk[cursor.getPosition() + 1] & 0x0F) * Math.pow(2, 48);

    switch (e) {
      case 0:
        e = -1022;
        break;
      case 2047:
        return m ? NaN : (signed ? -Infinity : Infinity);
      default:
        m += Math.pow(2, 52);
        e -= 1023;
    }

    if (signed) {
      m *= -1;
    }

    cursor.incrPosition(8);
  } else {
    cursor.breakParsing();
  }

  return m * Math.pow(2, e - 52);
};


/**
 * @inheritDoc
 */
thrift.protocol.Binary.prototype.readString = function(cursor, chunk) {
  var out = '';
  var len = this.readI32(cursor, chunk);

  if (cursor.isParsed()) {
    if (cursor.getPosition() + len <= chunk.length) {
      out = chunk.toString('utf8', cursor.getPosition(),
              cursor.getPosition() + len);
      cursor.incrPosition(len);
    } else {
      cursor.incrPosition(-4);
      cursor.breakParsing();
    }
  }

  return out;
};



/**
 * @param {number} type
 * @param {!thrift.protocol.IProtocol} protocol
 * @return {!thrift.IPacketHandler}
 */
thrift.protocol.MAP_HANDLER = function(type, protocol) {
  return new thrift.IncludedHandler(protocol,
      thrift.handlerBuilder,
      new thrift.protocol.MapKeeper(protocol));
};


/**
 * @param {number} type
 * @param {!thrift.protocol.IProtocol} protocol
 * @return {!thrift.IPacketHandler}
 */
thrift.protocol.ARRAY_HANDLER = function(type, protocol) {
  return new thrift.IncludedHandler(protocol,
      thrift.handlerBuilder,
      new thrift.protocol.ArrayKeeper(protocol));
};


/**
 * @param {number} type
 * @param {!thrift.protocol.IProtocol} protocol
 * @return {!thrift.IPacketHandler}
 */
thrift.protocol.FIELD_HANDLER = function(type, protocol) {
  return new thrift.IncludedHandler(protocol,
      thrift.handlerBuilder,
      new thrift.protocol.FieldKeeper(protocol));
};


/**
 * @param {number} type
 * @param {!thrift.protocol.IProtocol} protocol
 * @return {!thrift.IPacketHandler}
 */
thrift.protocol.STRUCTURE_HANDLER = function(type, protocol) {
  return new thrift.IncludedHandler(protocol,
      thrift.protocol.FIELD_HANDLER,
      new thrift.protocol.StructureKeeper(protocol));
};


/**
 * @param {!thrift.protocol.IProtocol} protocol
 * @return {!thrift.IPacketHandler}
 */
thrift.protocol.MESSAGE_HANDLER = function(protocol) {
  return new thrift.IncludedHandler(protocol,
      thrift.protocol.STRUCTURE_HANDLER,
      new thrift.protocol.MessageKeeper(protocol));
};




/**
 * @interface
 */
thrift.protocol.IProtocol = function() {};


/**
 * @return {!thrift.ISchema}
 */
thrift.protocol.IProtocol.prototype.getIdl = function() {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {!Object} userStructure
 * @param {!string} type
 */
thrift.protocol.IProtocol.prototype.serializeStructure =
    function(collector, userStructure, type) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {!Object} array
 * @param {!thrift.definition.FullType} valInfo
 */
thrift.protocol.IProtocol.prototype.serializeArray =
    function(collector, array, valInfo) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {!Object} map
 * @param {!thrift.definition.FullType} keyInfo
 * @param {!thrift.definition.FullType} valInfo
 */
thrift.protocol.IProtocol.prototype.serializeMap =
    function(collector, map, keyInfo, valInfo) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {string} methodName
 * @param {number} type
 * @param {number} seqid
 */
thrift.protocol.IProtocol.prototype.writeMessageHeader =
    function(collector, methodName, type, seqid) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} type
 * @param {number} id
 */
thrift.protocol.IProtocol.prototype.writeFieldHeader =
    function(collector, type, id) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 */
thrift.protocol.IProtocol.prototype.writeFieldStop = function(collector) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} ktype
 * @param {number} vtype
 * @param {number} size
 */
thrift.protocol.IProtocol.prototype.writeMapHeader =
    function(collector, ktype, vtype, size) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} type
 * @param {number} size
 */
thrift.protocol.IProtocol.prototype.writeListHeader =
    function(collector, type, size) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} type
 * @param {number} size
 */
thrift.protocol.IProtocol.prototype.writeSetHeader =
    function(collector, type, size) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {boolean} value
 */
thrift.protocol.IProtocol.prototype.writeBool = function(collector, value) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} value
 */
thrift.protocol.IProtocol.prototype.writeByte = function(collector, value) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} value
 */
thrift.protocol.IProtocol.prototype.writeI16 = function(collector, value) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} value
 */
thrift.protocol.IProtocol.prototype.writeI32 = function(collector, value) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {thrift.protocol.Int64|number} value
 */
thrift.protocol.IProtocol.prototype.writeI64 = function(collector, value) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {number} value
 */
thrift.protocol.IProtocol.prototype.writeDouble = function(collector, value) {};


/**
 * @param {!thrift.protocol.ChunkCollector} collector
 * @param {string} value
 */
thrift.protocol.IProtocol.prototype.writeString = function(collector, value) {};


/**
 * @param {!thrift.Cursor} cursor
 * @param {!Buffer} chunk
 * @return {boolean}
 */
thrift.protocol.IProtocol.prototype.readBool = function(cursor, chunk) {};


/**
 * @param {!thrift.Cursor} cursor
 * @param {!Buffer} chunk
 * @return {number}
 */
thrift.protocol.IProtocol.prototype.readByte = function(cursor, chunk) {};


/**
 * @param {!thrift.Cursor} cursor
 * @param {!Buffer} chunk
 * @return {number}
 */
thrift.protocol.IProtocol.prototype.readI16 = function(cursor, chunk) {};


/**
 * @param {!thrift.Cursor} cursor
 * @param {!Buffer} chunk
 * @return {number}
 */
thrift.protocol.IProtocol.prototype.readI32 = function(cursor, chunk) {};


/**
 * @param {!thrift.Cursor} cursor
 * @param {!Buffer} chunk
 * @return {thrift.protocol.Int64}
 */
thrift.protocol.IProtocol.prototype.readI64 = function(cursor, chunk) {};


/**
 * @param {!thrift.Cursor} cursor
 * @param {!Buffer} chunk
 * @return {number}
 */
thrift.protocol.IProtocol.prototype.readDouble = function(cursor, chunk) {};


/**
 * @param {!thrift.Cursor} cursor
 * @param {!Buffer} chunk
 * @return {string}
 */
thrift.protocol.IProtocol.prototype.readString = function(cursor, chunk) {};



/**
 * @constructor
 *
 * @param {!Buffer|number} int64
 */
thrift.protocol.Int64 = function(int64) {

  /**
   * @type {!Buffer}
   */
  this.__bytes = new Buffer(0);

  /**
   * @type {number}
   */
  this.__number = 0;

  if (int64 instanceof Buffer) {
    this.__bytes = int64;
    this.__number = this.binToDec(int64);
  } else {
    this.__bytes = this.decToBin(int64);
    this.__number = int64;
  }
};


/**
 * @type {number}
 */
thrift.protocol.Int64.prototype.MAX_VALUE = Math.pow(2, 53);


/**
 * @type {number}
 */
thrift.protocol.Int64.prototype.__MASK_32 = 0x100000000;


/**
 * @param {Buffer} chunk
 * @return {number}
 */
thrift.protocol.Int64.prototype.binToDec = function binToDec(chunk) {
  var negative = chunk[0] & 0x80;
  var dop = 1;
  var byte = 0;
  var value = 0;

  for (var i = 7; i >= 0; i--) {
    byte = chunk[i];

    if (negative) {
      byte = (byte ^ 0xff) + dop;
      dop = byte >> 8;
      byte = byte & 0xff;
    }
    value += byte * Math.pow(2, 8 * (7 - i));
  }

  if (value >= this.MAX_VALUE) {
    console.warn('Integer is outside range [thrift.protocol.Int64.binToDec]');
    value = Infinity;
  }

  return negative ? -value : value;
};


/**
 * @param {number} decNumber
 * @return {!Buffer}
 */
thrift.protocol.Int64.prototype.decToBin = function(decNumber) {
  var hight = Math.abs(decNumber) / this.__MASK_32;
  var low = Math.abs(decNumber) % this.__MASK_32;

  if (hight > this.__MASK_32) {
    console.warn('Integer is outside range [thrift.protocol.Int64.decToBin]');
  }

  var value = new Buffer(8);

  for (var i = 7; i >= 0; i--) {
    value[i] = low & 0xff;
    low = i == 4 ? hight : low >>> 8;
  }

  if (decNumber < 0) {
    var dop = 1;
    for (i = 7; i >= 0; i--) {
      var byte = (value[i] ^ 0xff) + dop;
      value[i] = byte & 0xff;
      dop = byte >> 8;
    }
  }

  return value;
};


/**
 * @return {!Buffer}
 */
thrift.protocol.Int64.prototype.getBuffer = function() {
  return this.__bytes;
};


/**
 * @return {number}
 */
thrift.protocol.Int64.prototype.getNumber = function() {
  return this.__number;
};




/**
 * @constructor
 */
thrift.protocol.ChunkCollector = function() {
  /**
   * @type {!Array.<!Buffer>}
   */
  this.__chunks = [];
  /**
   * @type {!number}
   */
  this.__length = 0;
};


/**
 * @param {!Buffer} chunk
 */
thrift.protocol.ChunkCollector.prototype.push = function(chunk) {
  this.__chunks.push(chunk);
  this.__length += chunk.length;
};


/**
 * @return {!Array.<!Buffer>}
 */
thrift.protocol.ChunkCollector.prototype.getChunks = function() {
  return this.__chunks;
};


/**
 * @return {!number}
 */
thrift.protocol.ChunkCollector.prototype.getLength = function() {
  return this.__length;
};


/**
 * @return {!Buffer}
 */
thrift.protocol.ChunkCollector.prototype.getTotalBytes = function() {
  return Buffer.concat(this.getChunks(), this.getLength());
};



/**
 * @constructor
 * @implements {thrift.IValueKeeper}
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.protocol.ArrayKeeper = function(protocol) {

  /**
   * @type {!thrift.protocol.IProtocol}
   */
  this.__protocol = protocol;

  /**
   * @type {number}
   */
  this.__type = -1;

  /**
   * @type {number}
   */
  this.__length = 0;

  /**
   * @type {!Array}
   */
  this.__result = [];

  /**
   * @type {boolean}
   */
  this.__isHeaderComplete = false;
};


/**
 * @inheritDoc
 */
thrift.protocol.ArrayKeeper.prototype.isHeaderComplete = function() {
  return this.__isHeaderComplete;
};


/**
 * @inheritDoc
 */
thrift.protocol.ArrayKeeper.prototype.processHeader = function(cursor, chunk) {
  if (this.__type === -1) {
    var type = this.__protocol.readByte(cursor, chunk);
    if (cursor.isParsed()) {
      this.__type = type;
    }
  }

  if (cursor.isParsed()) {
    var length = this.__protocol.readI32(cursor, chunk);
    if (cursor.isParsed()) {
      this.__length = length;
    }
  }

  this.__isHeaderComplete = cursor.isParsed();
};


/**
 * @inheritDoc
 */
thrift.protocol.ArrayKeeper.prototype.isComplete = function() {
  return this.__length === this.__result.length;
};


/**
 * @inheritDoc
 */
thrift.protocol.ArrayKeeper.prototype.applyData = function(value) {
  this.__result.push(value);
};


/**
 * @inheritDoc
 */
thrift.protocol.ArrayKeeper.prototype.get = function() {
  return this.__result;
};


/**
 * @return {number}
 */
thrift.protocol.ArrayKeeper.prototype.getType = function() {
  return this.__type;
};


/**
 * @return {number}
 */
thrift.protocol.ArrayKeeper.prototype.getLength = function() {
  return this.__length;
};



/**
 * @implements {thrift.IValueKeeper}
 * @constructor
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.protocol.FieldKeeper = function(protocol) {

  /**
   * @type {!thrift.protocol.IProtocol}
   */
  this.__protocol = protocol;

  /**
   * @type {thrift.Value}
   */
  this.__result = null;

  /**
   * @type {number}
   */
  this.__type = -1;

  /**
   * @type {number}
   */
  this.__id = -1;

  /**
   * @type {boolean}
   */
  this.__isComplete = false;

  /**
   * @type {boolean}
   */
  this.__isHeaderComplete = false;
};


/**
 * @inheritDoc
 */
thrift.protocol.FieldKeeper.prototype.processHeader = function(cursor, chunk) {
  if (this.__type === -1) {
    var type = this.__protocol.readByte(cursor, chunk);
    if (cursor.isParsed()) {
      this.__type = type;
    }
  }

  if (cursor.isParsed() && this.__type !== thrift.definition.Type.STOP) {
    var id = this.__protocol.readI16(cursor, chunk);
    if (cursor.isParsed()) {
      this.__id = id;
    }
  }

  this.__isHeaderComplete = cursor.isParsed();
};


/**
 * @inheritDoc
 */
thrift.protocol.FieldKeeper.prototype.isHeaderComplete = function() {
  return this.__isHeaderComplete;
};


/**
 * @inheritDoc
 */
thrift.protocol.FieldKeeper.prototype.applyData = function(value) {
  this.__isComplete = true;
  this.__result = new thrift.Field(this.__type, this.__id, value);
};


/**
 * @inheritDoc
 */
thrift.protocol.FieldKeeper.prototype.isComplete = function() {
  return this.__isComplete;
};


/**
 * @inheritDoc
 */
thrift.protocol.FieldKeeper.prototype.get = function() {
  return this.__result;
};


/**
 * @return {number}
 */
thrift.protocol.FieldKeeper.prototype.getType = function() {
  return this.__type;
};


/**
 * @return {number}
 */
thrift.protocol.FieldKeeper.prototype.getId = function() {
  return this.__id;
};



/**
 * @constructor
 * @implements {thrift.IValueKeeper}
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.protocol.MapKeeper = function(protocol) {

  /**
   * @type {!thrift.protocol.IProtocol}
   */
  this.__protocol = protocol;

  /**
   * @type {!Object}
   */
  this.__result = {};

  /**
   * @type {number}
   */
  this.__ktype = thrift.definition.Type.NOP;

  /**
   * @type {number}
   */
  this.__vtype = thrift.definition.Type.NOP;

  /**
   * @type {number}
   */
  this.__size = 0;

  /**
   * @type {!thrift.Value}
   */
  this.__key = null;

  /**
   * @type {number}
   */
  this.__pairCount = 0;

  /**
   * @type {number}
   */
  this.__curentType = this.__ktype;

  /**
   * @type {boolean}
   */
  this.__isHeaderComplete = false;
};


/**
 * @inheritDoc
 */
thrift.protocol.MapKeeper.prototype.isHeaderComplete = function() {
  return this.__isHeaderComplete;
};


/**
 * @inheritDoc
 */
thrift.protocol.MapKeeper.prototype.processHeader = function(cursor, chunk) {
  if (this.__ktype === -1) {
    var ktype = this.__protocol.readByte(cursor, chunk);
    if (cursor.isParsed()) {
      this.__ktype = ktype;
      this.__curentType = ktype;
    }
  }

  if (cursor.isParsed() && this.__vtype === -1) {
    var vtype = this.__protocol.readByte(cursor, chunk);
    if (cursor.isParsed()) {
      this.__vtype = vtype;
    }
  }

  if (cursor.isParsed()) {
    var size = this.__protocol.readI32(cursor, chunk);
    if (cursor.isParsed()) {
      this.__size = size;
    }
  }

  this.__isHeaderComplete = cursor.isParsed();
};


/**
 * @inheritDoc
 */
thrift.protocol.MapKeeper.prototype.applyData = function(value) {
  if (this.__key === null) {
    this.__key = value;
    this.__curentType = this.__vtype;
  } else {
    this.__result[this.__key] = value;
    this.__key = null;
    this.__curentType = this.__ktype;
    this.__pairCount++;
  }
};


/**
 * @inheritDoc
 */
thrift.protocol.MapKeeper.prototype.isComplete = function() {
  return this.__pairCount === this.__size;
};


/**
 * @inheritDoc
 */
thrift.protocol.MapKeeper.prototype.get = function() {
  return this.__result;
};


/**
 * @return {number}
 */
thrift.protocol.MapKeeper.prototype.getType = function() {
  return this.__curentType;
};



/**
 *
 * @implements {thrift.IValueKeeper}
 * @constructor
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.protocol.MessageKeeper = function(protocol) {

  /**
   * @type {!thrift.protocol.IProtocol}
   */
  this.__protocol = protocol;

  /**
   * @type {!thrift.ISchema}
   */
  this.__idl = protocol.getIdl();

  /**
   * @type {number}
   */
  this.__type = 0;

  /**
   * @type {!Object}
   */
  this.__result = {};

  /**
   * @type {string}
   */
  this.__name = '';

  /**
   * @type {number}
   */
  this.__id = -1;

  /**
   * @type {boolean}
   */
  this.__isHeaderComplete = false;

  /**
   * @type {boolean}
   */
  this.__isComplete = false;
};


/**
 * @inheritDoc
 */
thrift.protocol.MessageKeeper.prototype.isHeaderComplete = function() {
  return this.__isHeaderComplete;
};


/**
 * @inheritDoc
 */
thrift.protocol.MessageKeeper.prototype.processHeader =
    function(cursor, chunk) {

  if (this.__type === 0) {
    var info = this.__protocol.readI32(cursor, chunk);
    if (cursor.isParsed()) {
      this.__type = info & this.__protocol.TYPE_MASK;
    }
  }

  if (cursor.isParsed() && this.__name === '') {
    var name = this.__protocol.readString(cursor, chunk);
    if (cursor.isParsed()) {
      this.__name = name;
    }
  }

  if (cursor.isParsed() && this.__id === -1) {
    var id = this.__protocol.readI32(cursor, chunk);
    if (cursor.isParsed()) {
      this.__id = id;
    }
  }

  this.__isHeaderComplete = cursor.isParsed();
};


/**
 * @inheritDoc
 */
thrift.protocol.MessageKeeper.prototype.get = function() {
  return this.__result;
};


/**
 * @inheritDoc
 */
thrift.protocol.MessageKeeper.prototype.isComplete = function() {
  return this.__isComplete;
};


/**
 * @inheritDoc
 */
thrift.protocol.MessageKeeper.prototype.applyData = function(structure) {
  this.__isComplete = true;

  var payload = {};
  var methodDefinition = this.__idl.getMethodDefinition(this.__name);

  if (this.__type === thrift.definition.MessageType.CALL) {
    for (var id in structure) {
      var parameter = methodDefinition.getParameter(id);
      if (parameter !== null) {
        payload[parameter.getName()] = thrift.convertNestedStructure(
            structure[id], parameter.getFullType(), this.__idl);
      }
    }
  }

  if (this.__type === thrift.definition.MessageType.REPLY) {
    var fullReturnType = methodDefinition.getReturnType();
    var keysLength = structure instanceof Object ?
        Object.keys(structure).length :
        0;

    if (structure[0] !== undefined) {
      payload = thrift.convertNestedStructure(
          structure[0], fullReturnType, this.__idl);
    } else if (keysLength > 0) {
      this.__type = thrift.definition.MessageType.EXCEPTION;
      payload = structure;
    }
  }

  this.__result =
      new thrift.Message(this.__name, this.__type, this.__id, payload);
};


/**
 * @inheritDoc
 */
thrift.protocol.MessageKeeper.prototype.getType = function() {
  return this.__type;
};


/**
 * @return {number}
 */
thrift.protocol.MessageKeeper.prototype.getId = function() {
  return this.__id;
};


/**
 * @return {string}
 */
thrift.protocol.MessageKeeper.prototype.getName = function() {
  return this.__name;
};



/**
 * @constructor
 * @implements {thrift.IValueKeeper}
 * @param {!thrift.protocol.IProtocol} protocol
 */
thrift.protocol.StructureKeeper = function(protocol) {

  /**
   * @type {!thrift.protocol.IProtocol}
   */
  this.__protocol = protocol;

  /**
   * @type {!thrift.Value}
   */
  this.__result = {};

  /**
   * @type {boolean}
   */
  this.__isComplete = false;
};


/**
 * @inheritDoc
 */
thrift.protocol.StructureKeeper.prototype.processHeader =
    function(cursor, chunk) {};


/**
 * @inheritDoc
 */
thrift.protocol.StructureKeeper.prototype.isHeaderComplete = function() {
  return true;
};


/**
 * @inheritDoc
 */
thrift.protocol.StructureKeeper.prototype.applyData = function(field) {
  if (field instanceof thrift.Field) {
    if (field.getType() !== thrift.definition.Type.STOP) {
      this.__result[field.getId()] = field.getValue();
    } else {
      this.__isComplete = true;
    }
  }
};


/**
 * @inheritDoc
 */
thrift.protocol.StructureKeeper.prototype.isComplete = function() {
  return this.__isComplete;
};


/**
 * @inheritDoc
 */
thrift.protocol.StructureKeeper.prototype.get = function() {
  return this.__result;
};


/**
 * @inheritDoc
 */
thrift.protocol.StructureKeeper.prototype.getType = function() {
  return thrift.definition.Type.STRUCT;
};

module.exports = thrift;
